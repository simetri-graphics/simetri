{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#simetri-home","title":"S\u0130METR\u0130 Home","text":"<p>simetri.graphics (S\u0130METR\u0130) is a Python based graphics library that focuses on 2D symmetry operations and pattern generation. It uses the TikZ library and generates .tex files that can be compiled to create output files. It can also be used in Jupyter notebooks to create complex geometric patterns and designs. The library is designed to be easy to use and flexible, allowing users to create a wide variety of symmetrical patterns with minimal effort. The library also includes a number of computational geometry utility functions for working with 2D geometry.</p> <p>It is designed to be used in conjunction with XeLaTeX rendering engine. Currently the project is in its late alpha stages and is not ready for production use. Although this version is a proof of concept and is likely to change significantly in the future, it is already capable of producing some interesting results.</p> <p>S\u0130METR\u0130 can generate output files with .tex, .pdf, .ps, .eps, .svg, or .png extensions. It can also generate Jupyter notebook cells with the output embedded in them.</p> <ul> <li> <p>To install simetri.graphics use: <code>python3 -m pip install --upgrade simetri</code>   or <code>python -m pip install --upgrade simetri</code> More information about installation.</p> </li> <li> <p>To clone the development branch visit our GitHub page.</p> </li> </ul> <p></p>"},{"location":"examples_/","title":"Examples","text":""},{"location":"gallery/","title":"Gallery","text":"You can use <code>canvas.save(\"file_path\")</code> instead of (or along with) <code>canvas.display()</code> <p>All examples use canvas.display() to show the results in a Jupyter notebook. If you are using it as a stand alone library, use canvas.save(\"/your/path/here.pdf\") to save the output as a pdf file. You can generate .pdf, .svg, .ps, .eps, .tex, and .png output.</p> <pre><code>import simetri.graphics as sg\nimport simetri.wallpaper as wp\n\ncanvas = sg.Canvas(back_color = sg.burgundy)\n\nd = 20\ncd = sg.cos(sg.pi/4) * d\nx = 2 * cd * sg.cos(sg.pi/6)\np1 = (x - cd, 0)\np2 = (x, cd)\np3 = (x + cd, 0)\ndist = p3[0]\nkernel = sg.Shape([p1, p2, p3])\npetal = kernel.mirror(sg.axis_x, reps=1).merge_shapes()\nstar = petal.rotate(sg.pi/3, reps=5)\npattern = wp.cover_hex_flat(star, dist, reps1=3, reps2=4)\ncanvas.limits = (0, 0, 400, 300)\ncanvas.draw(pattern, fill_color=sg.colors.teal,\n                                line_width=2, fill=True)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ndef rotator(element, modifier, mult=1):\n    if modifier.count &gt;= 140 and mult == -1:\n        angle = -sg.pi/64\n    else:\n       angle = sg.pi/64\n    element.rotate(angle, about=element.center)\n\ndef painter(element):\n    element.fill_color = sg.change_lightness(element.fill_color, -.012)\n\ncanvas = sg.Canvas(back_color=sg.colors.light_gray)\nsqr = sg.reg_poly_shape((0, 0), 4, 18)\nsqr.fill_color = sg.gold\nbatch = sg.Batch([sqr]).translate(0, 25, 12)\nmod1 = sg.Modifier(rotator, life_span=140)\nmod2 = sg.Modifier(rotator, mult=-1)\nmod3 = sg.Modifier(painter)\nbatch.modifiers = [mod1, mod2, mod3]\nbatch.translate(dx=25, dy=0, reps=21)\ncanvas.draw(batch)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\ngrid = sg.CircularGrid(n=10, radius=175)\n\np1 = grid.intersect((1, 7), (2, 8))\np2 = grid.intersect((0, 3), (1, 7))\np3 = grid.points[0]\n\nkernel = sg.Shape([p1, p2, p3])\npetal = kernel.mirror(sg.axis_x, reps=1)\nstar = petal.rotate(sg.pi/5, reps=9)\nswatch = sg.swatches_255[23]\nlace = sg.Lace(star, offset=4, swatch = swatch)\ncanvas.draw(lace)\n\ngrid2 = sg.CircularGrid(n=10, radius=195)\nfor i in [0, 1, 2, 3, 7, 8]:\n    canvas.text(str(i), grid2.points[i], font_size=24)\n    canvas.circle(grid.points[i], radius=2)\n\nfor line in [(1, 7), (2, 8), (0, 3), (1, 7)]:\n    start, end = grid.points[line[0]], grid.points[line[1]]\n    canvas.line(start, end)\n\ncanvas.draw(sg.Shape([p1, p2, p3]), line_width=2)\n\nfor pnt in [p1, p2, p3]:\n    canvas.circle(pnt, radius=3, fill_color=sg.red)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\nsquare = sg.Shape([(0, 0), (300, 0), (300, 300), (0, 300)],\n                        closed=True, line_width=2, fill = False)\nrot_angle = sg.pi / 46\nscale_fac = 0.93\nscale_mat = sg.scale_in_place_matrix(scale_fac, scale_fac, square.center)\ntrans_mat = sg.translation_matrix(5, 0)\nrot_mat = sg.rotation_matrix(rot_angle, square.center)\ntransform_matrix = scale_mat @ rot_mat @ trans_mat\nsquares =   sg.Batch([square])\nsquares.transform(transform_matrix, reps=65)\n\ncanvas = sg.Canvas()\ncanvas.draw(squares)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nc = 4 # scale multiplier\nkernel = sg.Shape([(0, 6.5*c), (29*c, 6.5*c), (29*c, 0)])\npetal = kernel.mirror(sg.axis_x, reps=1)\nstar = petal.rotate(sg.pi/3, reps=5)\n\ncanvas.draw(star)\nstar = star.merge_shapes()\ndist = 47 * c\nstar2 = star.copy().translate(dist * sg.cos(sg.pi/6), dist * sg.sin(sg.pi/6))\nstar2.rotate(sg.pi/3, reps=5)\npattern = sg.Batch([star, star2])\nlace = sg.Lace(pattern, offset=4)\nlace.swatch =sg.colors.random_swatch()\ncanvas.draw(lace, line_width=2)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nw = 30\ndx = 2.75 * w\nsf_1 = 1.43 # scale factor 1\nsf_2 = .2 # scale factor 2\nsquare = sg.Shape([(0, 0), (w, w), (2 * w, 0), (w, -w)], closed=True)\nsquares = sg.Batch([square])\nsquares.translate(dx, 0).rotate(sg.pi/6, reps=11)\ntransform = sg.rotation_matrix(sg.pi/12) @ sg.scale_matrix(sf_1)\nsquares.transform(transform, reps=6).scale(sf_2, about=squares.center)\nfill_color = sg.red\nfor square in squares:\n    canvas.draw(square, fill_color = fill_color, stroke=False)\n    fill_color = sg.change_hue(fill_color, -.005)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\nsquare = sg.Batch([sg.reg_poly_shape(pos=(0, 0), n=4, r=100)])\n\nbatch = sg.Batch()\nsquare.translate(0, 120, reps=3)\nfor i in range(8):\n    square.translate(125, 0)\n    square.scale(.96, .94)\n    batch.extend([x.copy() for x in square.elements])\n\nbatch.mirror(batch.right, reps=1)\nbatch.mirror(batch.top, reps=1)\n\nlace = sg.Lace(batch, offset=5)\nlace.swatch = sg.qual_Pastel2_8\ncanvas.draw(lace.scale(.5))\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nw = 8\npoints  = [(0, 0), (-4, 0), (-4, 10), (4, 10),(4, 4), (0, 4), (0, 7)]\nkernel = sg.Shape(points).scale(w)\n\nlogo = kernel.rotate(sg.pi, reps=1).translate(8*w, -10*w, reps=1)\nlogo.append(sg.Shape([[12, -6], [12, -9]]).scale(w))\nfill_color = sg.Color(0.509, 0.678, 0.827)\ncanvas.draw(logo, line_width=2*w, line_color=fill_color)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ndef scaler(element):\n    return element.scale(.97)\n\nmod1 = sg.Modifier(scaler)\n\ncanvas = sg.Canvas()\ntime, signal = sg.sine_wave(amplitude=12, frequency=1, duration=6, sample_rate=15, phase=0)\ndamping = sg.damping_function(amplitude=.6, duration=6, sample_rate=15)\ndamped_signal = sg.array(signal) * sg.array(damping)\n\npoints = list(zip([x*60 for x in time], damped_signal))\nivy = sg.Shape(points, line_color=sg.brown)\ncanvas.draw(ivy.scale(2), line_width=8)\n\nleaf = sg.Shape([(0, 0), (20, 10), (30, 5), (45, 0)]).mirror(sg.axis_x, reps=1)\nleaf = leaf.merge_shapes()\nvein = sg.Shape([(0, 0), (45, 0)], line_color = sg.dark_green)\nleaf.append(vein)\nleaf.set_attribs('line_width', 1.5)\nvein2 = sg.Shape([(3, 0), (8, 5)], line_color=sg.dark_green).mirror(sg.axis_x, reps=1)\nvein2.translate(5, 0, reps=5)\nleaf.append(vein2)\nleaf = leaf.rotate(-sg.pi/6, leaf.west).scale(2).translate(10, 0)\n\nleaf.modifiers = [mod1]\nleaves = leaf.glide(glide_line=sg.axis_x, glide_dist=51, reps=18)\n\ncanvas.draw(leaves, smooth=True, fill_color=sg.green)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\nW, H, COLUMNS = 150, 150, 6\nDX = DY = MARGIN = 50\ncanvas = sg.Canvas( )\nns = [3, 5, 6]\ncombinations = list(sg.product(ns, ns, ns, ns))\nfor i in range(30):\n    row, col = i // COLUMNS, i % COLUMNS\n    x, y = (col * W) + MARGIN, (row * H) + MARGIN\n    dots = sg.Dots(marker_type=sg.MarkerType.FCIRCLE,\n    marker_size=1)\n    dots.translate(x+MARGIN, y+MARGIN)\n    combination = sg.choice(combinations)\n    combinations.remove(combination)\n    for n in combination:\n        dots.rotate(sg.two_pi/n, (x, y), reps=n-1)\n        dots.scale(.5, about=dots.center)\n        dots.translate(DX, DY)\n    canvas.draw(dots)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ndef arrow(start, end, head_length=10, head_width=4, both_ends=False):\n    length = sg.distance(start, end)\n    if length &lt;= head_length:\n        return sg.Batch()\n\n    shaft = sg.Shape([(0, 0), (length, 0)])\n    x = length - head_length\n    y = head_width/2\n    p1 = x, y\n    p2 = length, 0\n    p3 = x, -y\n    head = sg.Shape([p1, p2, p3], closed=True)\n\n    if both_ends:\n        p1_2 = head_length, y\n        p2_2 = 0, 0\n        p3_2 = head_length, -y\n        head2 = sg.Shape([p1_2, p2_2, p3_2], closed=True)\n        arrow_ = sg.Batch([shaft, head, head2])\n    else:\n        arrow_ = sg.Batch([shaft, head])\n\n    angle = sg.line_angle(start, end)\n    arrow_.rotate(angle)\n    arrow_.translate(*start)\n\n    return arrow_\n\nstart2 = (0, 0)\ndelta = sg.pi/36\nfor i in range(72):\n    angle = i * delta\n    start = sg.polar_to_cartesian(250, angle)\n    end = sg.polar_to_cartesian(250, sg.pi + angle)\n    canvas.draw(arrow(start, end, both_ends=True))\n    end2 = sg.polar_to_cartesian((i+1)*5, angle + delta/2)\n    canvas.draw(arrow(start2, end2))\n\ntime, signal = sg.sine_wave(amplitude=80, frequency=1, duration=4, sample_rate=20, phase=0)\npoints = list(zip([x*150 for x in time], signal))\nfor i, p in enumerate(points):\n    if i == 20:\n        canvas.draw(arrow((p[0], 0), p), fill_color= sg.yellow)\n    else:\n        canvas.draw(arrow((p[0], 0), p))\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\ncanvas.limits = (0, 0, 330, 330)\ndist = 110\noctagon = sg.reg_poly_shape((0, 0), 8, 100).rotate(sg.pi/8)\npattern = octagon.translate(0, dist, reps=3)\npattern.translate(dist, 0, reps=3)\nlace = sg.Lace(pattern, offset=6, swatch=sg.random_swatch())\ncanvas.draw(lace)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nw = 40\np1, p2 = sg.tri_to_cart([(w, w), (w, -2*w)])\npoints  = [p1, p2]\nkernel = sg.Shape(points)\nstar = kernel.rotate(sg.pi/3, reps=5).rotate(sg.pi/6)\nstar2 = star.copy().translate(4 * sg.cos(sg.pi/6) * w, 0)\nstar2.rotate(sg.pi/3, reps=5)\nswatch = sg.colors.random_swatch()\nlace = sg.Lace(sg.Batch([star, star2]), offset=6, swatch=swatch)\ncanvas.draw(lace.rotate(sg.pi/6))\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\nw = 20\npoints  = [(0, 0), (0, 2*w), (1*w, 1*w), (1*w, 0)]\nshape1 = sg.Shape(points,closed=True)\nshape1 = shape1.mirror((shape1[1], shape1[2]), reps=1)\ncanvas.draw(shape1)\nshape2 = shape1.copy().mirror(shape1.right).translate(-w, 2*w)\ncanvas.draw(shape2, fill_color=sg.gray)\nkernel = sg.Batch([shape1, shape2])\nkernel.translate(3*w, 0, reps=8).translate(0, 4*w, reps=5)\ncanvas.draw(kernel)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import numpy as np\n\nimport simetri.graphics as sg\n\ncanvas = sg.Canvas()\nw = .5\npoints  = [(0, 0), (0, 2*w), (1*w, 1*w), (1*w, 0)]\nshape1 = sg.Shape(points,closed=True)\nshape1 = shape1.mirror((shape1[1], shape1[2]), reps=1)\ncanvas.draw(shape1)\nshape2 = shape1.copy().mirror(shape1.right).translate(-w, 2*w)\ncanvas.draw(shape2, fill_color=sg.gray)\npattern = sg.Batch([shape1, shape2])\npattern.translate(3*w, 0, reps=8).translate(0, 4*w, reps=5)\ndef transform(batch, func):\n    '''Vectorize the function and apply it to the coordinates\n    of the segments in the batch'''\n    vec_func = np.vectorize(func)\n    shapes = []\n    for segment in batch.all_shapes:\n        coords = segment.final_coords\n        x, y = vec_func(coords[:, 0], coords[:, 1])\n        result = np.column_stack((x, y))\n        shapes.append(sg.Shape([(x, y) for x, y in result[:, :2]], closed=True))\n    return sg.Batch(shapes)\n\ndef transform_func(x, y):\n    '''z -&gt; z**2'''\n    a = complex(x, y)\n    res = a**2\n    return (res.real, res.imag)\n    # return (x**2 - y**2, 2*x*y)\n\ntransformed = transform(pattern, transform_func)\n\ncanvas.draw(transformed)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nseg = sg.Shape([(0, 0), (2, 0)])\nsegments = seg.translate(2, 0, reps=29)\nsegments.translate(0, 2, reps=29)\nsegments.rotate(sg.pi/2, segments.center, reps=1)\nsegments.translate(-30, 0)\ncanvas.draw(segments)\n\ndef transform(batch, func):\n    '''Vectorize the function and apply it to the coordinates\n    of the segments in the batch'''\n    vec_func = np.vectorize(func)\n    shapes = []\n    for segment in batch.all_shapes:\n        coords = segment.final_coords\n        x, y = vec_func(coords[:, 0], coords[:, 1])\n        result = np.column_stack((x, y))\n        shapes.append(sg.Shape([(x, y) for x, y in result[:, :2]], closed=True))\n    return sg.Batch(shapes)\n\ndef transform_func(x, y):\n    '''z -&gt; z-1/z+1'''\n    a = complex(x, y)\n    res = (a - 1) / ( a + 1)\n    return (res.real, res.imag)\n\ntransformed = transform(segments, transform_func)\n\ncanvas.draw(transformed.scale(2500), fill=False, line_width=2)\ncanvas.limits = (2200, 0, 3000, 500)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nc1 = sg.Circle((0, 0), 50)\ntransform = sg.scale_matrix(.7) @ sg.translation_matrix(85, 0)\ncircles = c1.transform(transform, reps=14).mirror(sg.axis_y, reps=1)\ntransform = sg.scale_matrix(.8) @ sg.rotation_matrix(sg.pi/7, (200, 0))\ncircles.transform(transform, reps=15).mirror(circles.right, reps=1)\ncanvas.draw(circles, line_width=3, fill_color=sg.navy)\n\ncanvas.display()\n</code></pre> <p></p>"},{"location":"installation/","title":"Installation","text":"<p>If you have a Python version &gt;= 3.9 installed, execute the following command in the terminal:</p> <p><code>python3 -m pip install --upgrade simetri</code></p> <p>or</p> <p><code>python -m pip install --upgrade simetri</code></p> <p>This will not install a LaTeX distribution, so you will need to install one separately.</p>"},{"location":"installation/#check-if-simetrigraphics-installation-is-successful","title":"Check if simetri.graphics installation is successful","text":"<p>In a terminal window type:</p> <p><code>xelatex -help</code></p> <p>If you get an error message, this may mean that you don't have a LaTeX installation or the path to the <code>xelatex</code> is not in your system path. Make sure that the system path includes the correct path to <code>xelatex</code>.</p> <p>Open a Python shell and type:</p> <p><code>&gt;&gt;&gt; import simetri.graphics as sg</code></p> <p><code>&gt;&gt;&gt; sg.__version__ # this should return '0.0.6'</code></p> <p><code>&gt;&gt;&gt; sg.hello()</code></p> <p>You should see a browser window showing you a welcome picture. If you don't see it, try</p> <p><code>&gt;&gt;&gt; sg.Canvas().draw(sg.logo()).save('/your/path/here.pdf')</code></p> <p>If you see the created PDF-file in the given path, this means that your system is preventing opening a web-browser window by third parties. You can use the simetri.graphics but your output files will not be shown automatically.</p> <p>If you would like to use Jupyter notebooks or JupyterLab you can use the same commands in a Python code-cell.</p>"},{"location":"installation/#install-a-latex-distribution","title":"Install a LaTeX distribution","text":"<p>There are several LaTeX distributions freely available for different operating systems. The recommended distribution is MacTex for macOS, TexLive for Linux and MikTeX for windows.</p> <ul> <li>TexLive can be downloaded from https://www.tug.org/texlive/.</li> <li>MacTeX can be downloaded https://www.tug.org/mactex/.</li> <li>MiKTeX can be downloaded https://miktex.org/download.</li> </ul>"},{"location":"installation/#install-jupyter-notebooks","title":"Install Jupyter notebooks","text":"<p>If you would like to run the scripts from a notebook environment, you need to install Jupyter Notebooks or JupyterLab. In some systems Jupyter may not use the system settings and behave different from the main Python environment.</p> <p>See https://jupyter.org/install</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python version 3.9 or later.</li> <li>A LaTeX distribution with XeLaTeX engine is required for rendering the output. Miktex is the recommended distribution since it handles installation of required packages automatically.</li> </ul> <p>The library requires the following Python packages:</p> <ul> <li><code>numpy</code></li> <li><code>networkx</code></li> <li><code>matplotlib</code></li> <li><code>Pillow</code></li> <li><code>IPython</code></li> <li><code>pymupdf</code></li> <li><code>strenum</code></li> <li><code>typing-extensions</code></li> <li><code>scipy</code></li> </ul> <p>These extensions are installed automatically when you install the library using pip or uv.</p>"},{"location":"markdown/","title":"Markdown Cheat Sheet","text":""},{"location":"markdown/#reference-links","title":"Reference links","text":""},{"location":"markdown/#in-the-same-page","title":"In the same page","text":"<p>Place <code>&lt;a id=\"sec_colored_headings\"&gt;&lt;/a&gt;</code> in the text to create a link to this section, and use <code>[Colored Headings](#sec_colored_headings)</code> to link to this section.</p> <p>The Colored Headings section explains ...</p>"},{"location":"markdown/#in-another-page","title":"In another page","text":"<p>Place <code>&lt;a id=\"sec_colored_headings\"&gt;&lt;/a&gt;</code> in colors.md to create a link. Use <code>[named-colors](topics/colors.md#sec_color_chart)</code> to link to the named colors section in the colors page.</p> <p>When creating RGB or HSV images, you can also use <code>sg.Color</code> objects or named-colors.  If the color is None, the image is not initialized.</p>"},{"location":"markdown/#a-url","title":"A URL","text":"<p>Use:</p> <pre><code>See [the documentation](https://pymupdf.readthedocs.io/en/latest/) for info.\n</code></pre> <p>For PDF images, S\u0130METR\u0130 uses the <code>PyMuPDf</code> library. You can see their documentation for further info.</p>"},{"location":"markdown/#code-blocks","title":"Code Blocks","text":"Transformed Canvas<pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\ncanvas.help_lines()\n\ncanvas.display()\n</code></pre>"},{"location":"markdown/#abbreviations","title":"Abbreviations","text":"<pre><code>The HTML specification\nis maintained by the W3C.\n\n*[HTML]: Hyper Text Markup Language\n*[W3C]:  World Wide Web Consortium\n\nwill be rendered as:\n\n&lt;p&gt;The &lt;abbr title=\"Hyper Text Markup Language\"&gt;HTML&lt;/abbr&gt; specification\nis maintained by the &lt;abbr title=\"World Wide Web Consortium\"&gt;W3C&lt;/abbr&gt;.&lt;/p&gt;\n</code></pre> <p>The HTML specification is maintained by the W3C.</p>"},{"location":"markdown/#images","title":"Images","text":""},{"location":"markdown/#captions","title":"Captions","text":"<pre><code>![Shape diagram](assets/shape_diagram.png){ width=\"300\" align=\"left\"}\n/// caption\nStructure of `Shape` objects.\n///\n</code></pre> <p>Structure of <code>Shape</code> objects.</p>"},{"location":"markdown/#ending-alignment","title":"Ending alignment","text":"<pre><code>![Transformed help-lines](assets/help_lines2.png){ width=\"300\" align=\"left\"}\nThis text is to the right of the image.\n&lt;BR CLEAR=\"left\"&gt;\n\nThis should be below the image.\n</code></pre> <p> This text is to the right of the image. </p> <p>This should be below the image.</p>"},{"location":"markdown/#captions_1","title":"Captions","text":"<p>Use:</p> <pre><code>![Shape diagram](assets/shape_diagram2.svg){ width=\"300\"}\n/// caption\nStructure of `Shape` objects.\n///\n</code></pre> <p></p> <p>Structure of <code>Shape</code> objects.</p>"},{"location":"markdown/#math-fonts","title":"Math fonts","text":"<pre><code>&lt;span style=\"font-family: 'Cambria Math', sans-serif;\"&gt;n = (1 + 1)\u2219(3 + 1)\u2219(4 + 1)\u22193 = 120&lt;/span&gt;\n</code></pre> <p>n = (1 + 1)\u2219(3 + 1)\u2219(4 + 1)\u22193 = 120</p> <p> n = (1 + 1)\u2219(3 + 1)\u2219(4 + 1)\u22193 = 120</p> <p>n</p> <p>\\(n = (1 + 1)(3 + 1)(4 + 1)3 = 120\\)</p>"},{"location":"markdown/#inline-code","title":"Inline Code","text":"<p><pre><code>`#!python PIL.Image.new(mode: str, size: tuple[int, int]) \u2192 Image[source]`\n</code></pre> <code>PIL.Image.new(mode: str, size: tuple[int, int] | list[int], color: float | tuple[float, ...] | str | None = 0) \u2192 Image[source]</code></p>"},{"location":"markdown/#definition-lists","title":"Definition lists","text":"<pre><code>Apple\n:   Pomaceous fruit of plants of the genus Malus in\n    the family Rosaceae.\n\nOrange\n:   The fruit of an evergreen tree of the genus Citrus.\n\nWill be rendered as:\n\n&lt;dl&gt;\n&lt;dt&gt;Apple&lt;/dt&gt;\n&lt;dd&gt;Pomaceous fruit of plants of the genus Malus in\nthe family Rosaceae.&lt;/dd&gt;\n\n&lt;dt&gt;Orange&lt;/dt&gt;\n&lt;dd&gt;The fruit of an evergreen tree of the genus Citrus.&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre> Apple Pomaceous fruit of plants of the genus Malus in the family Rosaceae. Orange The fruit of an evergreen tree of the genus Citrus."},{"location":"markdown/#admonitions","title":"Admonitions","text":"<p>Documentation</p>"},{"location":"markdown/#collapsible-admonitions","title":"Collapsible Admonitions","text":"PIL uses a flipped y-axis and the origin is located at the upper-left corner! <p>The origin of PIL Image objects is located at the upper right corner.  To align with the rest of the S\u0130METR\u0130 library, the origin of sg.Image objects is positioned at the lower left corner, with the positive y direction pointing upwards.</p> <p>Supported types Following is a list of type qualifiers provided by Material for MkDocs, whereas the default type, and thus fallback for unknown type qualifiers, is note:</p> <p>Previously, some of the supported types defined more than one qualifier. For example, authors could use summary or tldr as alternative qualifiers to render an abstract admonition. As this increased the size of the CSS that is shipped with Material for MkDocs, the additional type qualifiers are now all deprecated and will be removed in the next major version. This will also be mentioned in the upgrade guide.</p> <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Abstract</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Tip</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Success</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Question</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Warning</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Failure</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Danger</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Bug</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Example</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p>Quote</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et   euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo   purus auctor massa, nec semper lorem quam in massa.</p> <p></p>"},{"location":"markdown/#colored-headings","title":"Colored Headings","text":""},{"location":"markdown/#supported-image-formats","title":"Supported image formats","text":""},{"location":"math/","title":"Math","text":""},{"location":"math/#math","title":"Math","text":""},{"location":"math/#matrices","title":"Matrices","text":""},{"location":"math/#sets","title":"Sets","text":""},{"location":"math/#vectors","title":"Vectors","text":""},{"location":"math/#graphs","title":"Graphs","text":""},{"location":"math/#groups","title":"Groups","text":""},{"location":"reading/","title":"Reading","text":""},{"location":"reading/#reading","title":"Reading","text":"<p>These are the books that I used and liked. There will be brief summaries of each book. Books are grouped by their tags and each book may have one or more tags. You can view a list of categorized books in the tags page.</p> <p> </p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:color-symmetry","title":"Color Symmetry","text":"<ul> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> </ul>"},{"location":"tags/#tag:design-how-to","title":"Design how to","text":"<ul> <li>            Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer          </li> </ul>"},{"location":"tags/#tag:escher","title":"Escher","text":"<ul> <li>            M.C. Escher : Visions of Symmetry by Doris Schattschneider          </li> </ul>"},{"location":"tags/#tag:frieze-groups","title":"Frieze Groups","text":"<ul> <li>            Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)          </li> <li>            Islamic Ornamental Design by Claude Humbert          </li> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> </ul>"},{"location":"tags/#tag:graph-theory","title":"Graph Theory","text":"<ul> <li>            Introduction to Graph Theory by Richard J. Trudeau          </li> </ul>"},{"location":"tags/#tag:group-theory","title":"Group Theory","text":"<ul> <li>            The Fascination of Groups by F.J. Budden          </li> </ul>"},{"location":"tags/#tag:historic-patterns","title":"Historic Patterns","text":"<ul> <li>            Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez          </li> <li>            Bonner          </li> <li>            How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela          </li> <li>            The Topkapi Scroll: Geometry and Ornament in Islamic Architecture by G\u00fclru Necipo\u011flu          </li> <li>            Traditional Islamic Craft in Moroccan Architecture (Vol.1 &amp; 2) by Andre Paccard          </li> </ul>"},{"location":"tags/#tag:history","title":"History","text":"<ul> <li>            Islamic Ornamental Design by Claude Humbert          </li> </ul>"},{"location":"tags/#tag:how-to-draw","title":"How to Draw","text":"<ul> <li>            Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez          </li> <li>            Bonner          </li> <li>            How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela          </li> </ul>"},{"location":"tags/#tag:hyerbolic-tilings","title":"Hyerbolic Tilings","text":"<ul> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> </ul>"},{"location":"tags/#tag:igp","title":"IGP","text":"<ul> <li>            Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez          </li> <li>            Bonner          </li> <li>            How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela          </li> <li>            The Topkapi Scroll: Geometry and Ornament in Islamic Architecture by G\u00fclru Necipo\u011flu          </li> <li>            Traditional Islamic Craft in Moroccan Architecture (Vol.1 &amp; 2) by Andre Paccard          </li> </ul>"},{"location":"tags/#tag:illustrations","title":"Illustrations","text":"<ul> <li>            Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez          </li> <li>            Bonner          </li> <li>            Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer          </li> <li>            Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)          </li> <li>            How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela          </li> <li>            Islamic Ornamental Design by Claude Humbert          </li> <li>            M.C. Escher : Visions of Symmetry by Doris Schattschneider          </li> <li>            Mathematical Illustrations by Robert Casselman          </li> <li>            Space Tessellations: Experimenting with Parquet Deformations by Werner van Hoeydonck (Editor), Christian Kern (Editor), Eva Sommeregger (Editor)          </li> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> <li>            Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2nd Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard          </li> </ul>"},{"location":"tags/#tag:math","title":"Math","text":"<ul> <li>            Introduction to Graph Theory by Richard J. Trudeau          </li> <li>            Mathematical Illustrations by Robert Casselman          </li> <li>            The Fascination of Groups by F.J. Budden          </li> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> <li>            Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2nd Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard          </li> </ul>"},{"location":"tags/#tag:morrocco","title":"Morrocco","text":"<ul> <li>            Traditional Islamic Craft in Moroccan Architecture (Vol.1 &amp; 2) by Andre Paccard          </li> </ul>"},{"location":"tags/#tag:parquet-deformations","title":"Parquet Deformations","text":"<ul> <li>            Space Tessellations: Experimenting with Parquet Deformations by Werner van Hoeydonck (Editor), Christian Kern (Editor), Eva Sommeregger (Editor)          </li> </ul>"},{"location":"tags/#tag:patterns","title":"Patterns","text":"<ul> <li>            Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer          </li> <li>            Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)          </li> <li>            Islamic Ornamental Design by Claude Humbert          </li> <li>            M.C. Escher : Visions of Symmetry by Doris Schattschneider          </li> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> <li>            Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2nd Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard          </li> </ul>"},{"location":"tags/#tag:postscript","title":"Postscript","text":"<ul> <li>            Mathematical Illustrations by Robert Casselman          </li> </ul>"},{"location":"tags/#tag:reference","title":"Reference","text":"<ul> <li>            The Fascination of Groups by F.J. Budden          </li> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> <li>            Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2nd Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard          </li> </ul>"},{"location":"tags/#tag:symmetry","title":"Symmetry","text":"<ul> <li>            Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez          </li> <li>            Bonner          </li> <li>            Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer          </li> <li>            Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)          </li> <li>            How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela          </li> <li>            Islamic Ornamental Design by Claude Humbert          </li> <li>            M.C. Escher : Visions of Symmetry by Doris Schattschneider          </li> <li>            Space Tessellations: Experimenting with Parquet Deformations by Werner van Hoeydonck (Editor), Christian Kern (Editor), Eva Sommeregger (Editor)          </li> </ul>"},{"location":"tags/#tag:simetri-basics","title":"S\u0130METR\u0130 Basics","text":"<ul> <li>            A simple triangle shape          </li> </ul>"},{"location":"tags/#tag:tilings","title":"Tilings","text":"<ul> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> <li>            Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2nd Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard          </li> </ul>"},{"location":"tags/#tag:wallpaper-groups","title":"Wallpaper Groups","text":"<ul> <li>            Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer          </li> <li>            Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)          </li> <li>            Islamic Ornamental Design by Claude Humbert          </li> <li>            M.C. Escher : Visions of Symmetry by Doris Schattschneider          </li> <li>            The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss          </li> </ul>"},{"location":"tags/#tag:images","title":"images","text":"<ul> <li>            Images          </li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#simetrigraphics-tutorials","title":"simetri.graphics Tutorials","text":""},{"location":"tutorials/#_1","title":"Tutorials","text":"<ul> <li>A simple <code>Shape</code></li> </ul>"},{"location":"books/anadolu_selcuklu_sanati/","title":"Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez","text":"","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/anadolu_selcuklu_sanati/#the-geometric-language-of-anatolian-seljuk-art","title":"The Geometric Language of Anatolian Seljuk Art","text":"<p>This is a gorgeous three volume set that explores the geometric patterns found in Anatolian Seljuk art. The book is a comprehensive study of the geometric patterns used in the art and architecture of the Seljuk period in Anatolia, which lasted from the 11<sup>th</sup> to the 13<sup>th</sup> centuries. The author, Serap Ekizler S\u00f6nmez, has meticulously documented and analyzed these patterns.</p> <p>It went out of print quickly, and it is very hard to find. The book is a treasure trove of information for anyone interested in Islamic art, geometry, or the history of the Seljuk period. It is beautifully illustrated with high-quality images and diagrams that help to explain the complex geometric patterns.</p> <p>The book is in Turkish, but it is a how to draw book filled with whole page illustrations with no text, and you would not be missing much if you do not read Turkish.</p> <p>Translated from the publisher's website: \"We proudly present the Geometric Language of Anatolian Seljuk Art, a two-year effort by Serap Ekizler S\u00f6nmez, who has created a special work for architects, mathematicians, art historians, science historians, designers, traditional artists and anyone interested in geometric pattern analysis.</p> <p>Geometric patterns, the most powerful indicators of the richness of the connection between science and art in Islamic Civilization, continue to live with us like doors opening to the soul of the lands we live on. Serap Ekizler S\u00f6nmez, who traveled every inch of this magnificent richness of Anatolia for two years and created both its visual and theoretical infrastructure, has presented a treasure to our cultural world. Knowing that the language of the cosmos is geometry, this giant work, which points out that art is a nation's effort to comprehend the world, also offers a proposal on how tradition can nourish the future.</p> <p>In this work, which took more than 2 years to prepare and in which a total of 64 historical monuments from 23 cities were studied in detail, 118 patterns in various architectural structures were analyzed and how they emerged was explained step by step and shown in 1487 drawings.</p> <p>The production of 118 patterns selected from those with a systematic geometric substructure was achieved with both ruler-compass construction, polygonal systems and different perspectives allowed by geometry. The most important aspect of the book that distinguishes it from other analysis books is that it draws attention to the kinship relationships between patterns and provides guiding approaches to create new designs. When viewed from this aspect, it can be said that it contains much more designs than the number of patterns analyzed.\"</p>","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/anadolu_selcuklu_sanati/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/beyer/","title":"Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer","text":"<p>This is a very good book for anyone interested in designing tessellations and interlocking patterns. The author, Jinny Beyer, is a well-known quilter and designer, and she provides a wealth of information on the subject. She has been teaching and designing for over 30 years, and her expertise shines through in this book.</p> <p>Unlike many other books on the subject, this one is not just a collection of patterns. Instead, it focuses on the principles of design and how to create your own unique tessellations. The author provides clear explanations and step-by-step instructions for creating wallpaper-patterns.</p> <p>Even though she is not a mathematician, she has a good understanding of the mathematical principles underlying tessellations and patterns. She explains these concepts in a way that is accessible to readers without a strong math background.</p> <p>I enjoyed this book a lot.</p>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#table-of-contents","title":"Table of Contents","text":"<p>Title Page Copyright Page Dedication Introduction Acknowledgements</p>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-1-what-are-tessellations","title":"CHAPTER 1 - What Are Tessellations?","text":"<pre><code>From Simple Tessellations to Escher-Type Designs\nSymmetry and Tessellations\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-2-an-introduction-to-symmetry","title":"CHAPTER 2 - An Introduction to Symmetry","text":"<pre><code>Pattern\nTypes of Symmetry\nWays to Generate Symmetrical Patterns\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-3-desining-with-two-dimensional-symmetries-the-firsteleven","title":"CHAPTER 3 - Desining with Two-Dimensional Symmetries: The FirstEleven ...","text":"<pre><code>Working with Symmetries\nMultiple Patterns from a Single Cell\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-4-designing-with-two-dimensional-symmetries-the-last-six-symmetry-groups","title":"CHAPTER 4 - Designing with Two-Dimensional Symmetries: The Last Six Symmetry Groups","text":"<pre><code>12. Traditional Block (p4m) Symmetry\n13. Three Rotation (p3) Symmetry\n14. Six Rotation (p6) Symmetry\n15. Mirror and Three-Rotation (p3m1) Symmetry\n16. Three Rotations and a Mirror (p31m) Symmetry\n17. Kaleidoscope (p6m) Symmetry\nSummary of Two-Dimensional Symmetry Groups\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-5-designing-with-linear-symmetry-groups","title":"CHAPTER 5 - Designing with Linear Symmetry Groups","text":"<pre><code>The Seven Linear Symmetry Groups\nThe Linear Symmetry Groups\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-6-experimenting-with-symmetry","title":"CHAPTER 6 - Experimenting with Symmetry","text":"<pre><code>Applying Other Symmetries to the Primary Cell\nDesigning Your Own Primary Cell\nSymmetry Breaking\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-7-the-keys-to-creating-interlocking-tessellations","title":"CHAPTER 7 - The Keys to Creating Interlocking Tessellations","text":"<pre><code>Creating Interlocking Shapes\nCombining Operations\nTessellating Borders\nEndless Design Possibilities\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-8-refining-tessellations-shape-and-color","title":"CHAPTER 8 - Refining Tessellations: Shape and Color","text":"<pre><code>Preparing Tessellations for Construction in Surface Design\nPreparing Tessellations for Color and Value\nDesign Options for All Media\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-9-creating-geometric-tessellations","title":"CHAPTER 9 - Creating Geometric Tessellations","text":"<pre><code>Tessellations for All Surface Designers\nThe Miraculous Effects of Value and Contrast\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-10-creating-representational-tessellations","title":"CHAPTER 10 - Creating Representational Tessellations","text":"<pre><code>Escher\u2019s Vision\nEscher\u2019s Techniques\nMaking Representational Tessellations\nMultimotif Designs\nExperimenting with Multimotif Designs\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#chapter-11-metamorphosis","title":"CHAPTER 11 - Metamorphosis","text":"<pre><code>Moving from One Geometric Shape to Another\nMoving from Geometric Shapes to Representational Images\nEscher\u2019s Legacy\n</code></pre>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#appendix","title":"Appendix","text":"<pre><code>Appendix A\nAppendix B\nAppendix C\n</code></pre> <p>Credits</p>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/beyer/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Design how to","Patterns","Symmetry","Wallpaper Groups"]},{"location":"books/bonner/","title":"Bonner","text":"<p># Islamic Geometric Patterns  ## Their Historical Development and Traditional Methods of Construction  ## by Jay Bonner and Craig S. Kaplan</p> <p></p> <p> </p>","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/bonner/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/casselman/","title":"Mathematical Illustrations by Robert Casselman","text":"<p>This is the best introduction to PostScript I have ever seen. It is a bit old, but it is still relevant. The book is well-structured and covers a wide range of topics, including basic drawing, coordinate transformations, curves, and 3D graphics. The author provides clear explanations and examples, making it easy to follow along. The book also includes exercises and code snippets to help reinforce the concepts learned.</p> <p>The author, Robert Casselman, is a mathematician and computer scientist who has a deep understanding of the subject matter. He presents the material in a way that is both engaging and informative. The book is suitable for anyone interested in learning about mathematical illustrations and PostScript programming.</p> <p>Even if you don't have a specific interest in PostScript, this book is a great resource for anyone looking to improve their understanding of mathematics and computer graphics. The author provides a wealth of information and insights that are applicable to a wide range of fields.</p> <p>The book is available for free online.</p>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#table-of-contents","title":"Table of Contents","text":"","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-1-getting-started-in-postscript","title":"Chapter 1. Getting started in PostScript","text":"<ol> <li>Simple drawing 2</li> <li>Simple coordinate changes 7</li> <li>Coordinate frames 9</li> <li>Doing arithmetic in PostScript 11</li> <li>Errors 14</li> <li>Working with files and viewers GhostView or GSView 16</li> <li>Some fine points 19</li> <li>A trick for eliminating redundancy 22</li> <li>Summary 22</li> <li>Code 24</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-2-elementary-coordinate-geometry-26","title":"Chapter 2. Elementary coordinate geometry 26","text":"<ol> <li>Points and vectors 26</li> <li>Areas of parallelograms 27</li> <li>Lengths 32</li> <li>Vector projections 34</li> <li>Rotations 37</li> <li>The cosine rule 39</li> <li>Dot products in higher dimensions 41</li> <li>Lines 41</li> <li>Code 44</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-3-variables-and-procedures-46","title":"Chapter 3. Variables and procedures 46","text":"<ol> <li>Variables in PostScript 46</li> <li>Procedures in PostScript 48</li> <li>Keeping track of where you are 50</li> <li>Passing arguments to procedures 52</li> <li>Procedures as functions 54</li> <li>Local variables 55</li> <li>A final improvement 57</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-4-coordinates-and-conditionals-59","title":"Chapter 4. Coordinates and conditionals 59","text":"<ol> <li>Coordinates 59</li> <li>How PostScript stores coordinate transformations 62</li> <li>Picturing the coordinate system 65</li> <li>Moving into three dimensions 67</li> <li>How coordinate changes are made 71</li> <li>Drawing infinite lines: conditionals in PostScript 73</li> <li>Another way to draw lines 78</li> <li>Clipping 81</li> <li>Order counts 82</li> <li>Code 83</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-5-drawing-polygons-loops-and-arrays-84","title":"Chapter 5. Drawing polygons: loops and arrays 84","text":"<ol> <li>The repeat loop 84</li> <li>The for loop 86</li> <li>The loop loop 87</li> <li>Graphing functions 87</li> <li>General polygons 88</li> <li>Clipping polygons 90</li> <li>Code 94</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-6-curves-95","title":"Chapter 6. Curves 95","text":"<ol> <li>Arcs 95</li> <li>Fancier curves 96</li> <li>Bezier curves \u00b4 97</li> <li>How to use Bezier curves \u00b4 100</li> <li>The mathematics of Bezier curves \u00b4 108</li> <li>Quadratic Bezier curves \u00b4 109</li> <li>Mathematical motivation 110</li> <li>Weighted averages 113</li> <li>How the computer draws Bezier curves \u00b4 116</li> <li>Bernstein polynomials 118</li> <li>This section brings you the letter O 120</li> </ol> <p>Interlude 123</p>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-7-drawing-curves-automatically-procedures-as-arguments-126","title":"Chapter 7. Drawing curves automatically: procedures as arguments 126","text":"<ol> <li>Drawing an hyperbola 126</li> <li>Parametrized curves 130</li> <li>Drawing graphs automatically 131</li> <li>Drawing parametrized paths automatically 133</li> <li>How to use it 135</li> <li>How it works 137</li> <li>Code 138</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-8-non-linear-2d-transformations-deconstructing-paths-140","title":"Chapter 8. Non-linear 2D transformations: deconstructing paths 140","text":"<ol> <li>Two dimensional transformations 140</li> <li>Conformal transforms 144</li> <li>Transforming paths 145</li> <li>Maps 146</li> <li>Fonts want to be free 150</li> <li>Code 150 Chapter 9. Recursion in PostScript 153</li> <li>The perils of recursion 153</li> <li>Sorting 155</li> <li>Convex hulls 159</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-10-perspective-and-homogeneous-coordinates-165","title":"Chapter 10. Perspective and homogeneous coordinates 165","text":"<ol> <li>The projective plane 167</li> <li>Boy\u2019s surface 169</li> <li>Projective transformations 171</li> <li>The fundamental theorem 172</li> <li>Projective lines 175</li> <li>A remark about solving linear systems 176</li> <li>The GIMP perspective tool, revisited 179</li> <li>Projections in 2D 180</li> <li>Perspective in 3D 181</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-11-introduction-to-drawing-in-three-dimensions-185","title":"Chapter 11. Introduction to drawing in three dimensions 185","text":"","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-12-transformations-in-3d-187","title":"Chapter 12. Transformations in 3D 187","text":"<ol> <li>Rigid transformations 187</li> <li>Dot and cross products 189</li> <li>Linear transformations and matrices 195</li> <li>Changing coordinate systems 198</li> <li>Rigid linear transformations 201</li> <li>Orthogonal transformations in 2D 202</li> <li>Orthogonal transformations in 3D 204</li> <li>Calculating the effect of an axial rotation 207</li> <li>Finding the axis and angle 209</li> <li>Euler\u2019s Theorem 210</li> <li>More about projections 211</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-13-postscript-in-3d-212","title":"Chapter 13. PostScript in 3D 212","text":"<ol> <li>A survey of the package 213</li> <li>The 3D graphics environment 217</li> <li>Coordinate transformations 219</li> <li>Drawing 221</li> <li>Surfaces 222</li> <li>Code 223</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-14-drawing-surfaces-in-3d-225","title":"Chapter 14. Drawing surfaces in 3D 225","text":"<ol> <li>Faces 225</li> <li>Polyhedra 227</li> <li>Visibility for convex polyhedra 229</li> <li>Shading 231</li> <li>Smooth surfaces 235</li> <li>Smoother surfaces 239</li> <li>Abandoning convexity 244</li> <li>Summary 249</li> <li>Code 250</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#chapter-15-the-regular-polyhedra-252","title":"Chapter 15. The regular polyhedra 252","text":"<ol> <li>What exactly is a regular polyhedron? 253</li> <li>There are no more than five regular solids 254</li> <li>The proof of Euclid XI.21 258</li> <li>Trihedral angles 261</li> <li>The results we need from Book I 263</li> <li>Constructing the regular polyhedra 265</li> <li>Verifying regularity 269</li> <li>Code 269</li> <li>References 272</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-1-summary-of-postscript-commands-274","title":"Appendix 1. Summary of PostScript commands 274","text":"<ol> <li>Mathematical functions 274</li> <li>Stack operations 275</li> <li>Arrays 276</li> <li>Dictionaries 277</li> <li>Conditionals 277</li> <li>Loops 278</li> <li>Conversions 279</li> <li>File handling and miscellaneous 279</li> <li>Display 280</li> <li>Graphics state 281</li> <li>Coordinates 282</li> <li>Drawing 283</li> <li>Displaying text 284</li> <li>Errors 285</li> <li>Alphabetical list 285</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-2-setting-up-your-postscript-environment-288","title":"Appendix 2. Setting up your PostScript environment 288","text":"<ol> <li>Editing PostScript files 288</li> <li>Running external files 289</li> <li>Making images 290</li> <li>Printing files 291</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-3-structured-postscript-documents-293","title":"Appendix 3. Structured PostScript documents 293","text":"","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-4-simple-text-display-296","title":"Appendix 4. Simple text display 296","text":"<ol> <li>Simple PostScript text 296</li> <li>Outline fonts 298</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-5-zooming-300","title":"Appendix 5. Zooming 300","text":"<ol> <li>Zooming 300</li> <li>An explicit procedure 301</li> <li>Playing around 302</li> <li>Code 303</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-6-evaluating-polynomials-getting-along-without-variables-304","title":"Appendix 6. Evaluating polynomials: getting along without variables 304","text":"<ol> <li>The most straightforward way to do it 304</li> <li>Horner\u2019s method 305</li> <li>Evaluating the derivatives efficiently 307</li> <li>Evaluating Bernstein polynomials 309</li> <li>Code 310</li> </ol>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#appendix-7-importing-postscript-files-311","title":"Appendix 7. Importing PostScript files 311","text":"<ol> <li>Labelling a graph 311</li> <li>Importing TEX text 315</li> <li>Fancy work 317</li> </ol> <p>Epilogue 321</p>","tags":["Illustrations","Postscript","Math"]},{"location":"books/casselman/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Postscript","Math"]},{"location":"books/handbook_of_reg_patterns/","title":"Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)","text":"<p>This book explores symmetry and pattern structures across different cultures and periods. It covers a wide range of topics, including symmetry groups, frieze patterns, wallpaper groups, and the mathematical principles underlying these concepts. The book is well-illustrated and includes many examples and exercises to help readers understand the material. Extensive coverage of historic examples of Frieze groups.</p>","tags":["Illustrations","Patterns","Frieze Groups","Wallpaper Groups","Symmetry"]},{"location":"books/handbook_of_reg_patterns/#table-of-contents","title":"Table of Contents:","text":"<p>I. Symmetry Groups</p> <ol> <li>Basic Operations - 2</li> <li>How Operations Generate Themselves - 10</li> </ol> <p>II. Point Groups</p> <ol> <li>Point Groups - 18</li> <li>The Asymmetric Motif: Group 1 - 22</li> <li>Bilateral Symmetry: Group m - 28</li> <li>Playing Cards and Walnuts: Groups 2 and 2mm - 38</li> <li>The Triskelion and the Green Pepper: Groups 3 and 3m - 52</li> <li>The Swastika and the Greek Cross: Groups 4 and 4mm - 58</li> <li>Flowers and Pentagrams: Groups 5 and 5m - 72</li> <li>Solomon\u2019s Seal and Snowflakes: Groups 6 and 6mm - 80</li> <li>Stars and Circles: Point Groups of Higher Order - 84</li> </ol> <p>III. The Seven Line Groups</p> <ol> <li>Ducks in a Row: Group t - 96</li> <li>Friday\u2019s Footprints: Group tg - 106</li> <li>Reflected Reflections: Group tm - 118</li> <li>Reflected Sails: Group mt - 126</li> <li>Grand Right and Left: Group f2 - 136</li> <li>Reflected Whirls: Group t2mg - 148</li> </ol> <p>IV. The Seventeen Plane Groups</p> <ol> <li>Linear Kaleidoscope: Group t2mm - 158</li> <li>Recapitulation - 166</li> <li>Two Nonparallel Translations: Group p1 - 170</li> <li>Two Parallel Glide Reflections: Group pg - 182</li> <li>Two Parallel Mirrors: Group pm - 192</li> <li>A Reflection and a Parallel Glide Reflection: Group cm - 198</li> <li>Four Half-Turns: Group p2 - 208</li> <li>A Mirror and a Perpendicular Glide Reflection: Group p2mg - 218</li> <li>Two Perpendicular Glide Reflections: Group p2gg - 230</li> <li>Reflections in Four Sides of a Rectangle: Group p2mm - 242</li> <li>Perpendicular Mirrors and Perpendicular Glide Reflections: Group c2mm - 248</li> <li>Three Rotations Through 120\u00b0: Group p3 - 258</li> <li>Reflections in an Equilateral Triangle: Group p3m1 - 264</li> <li>Reflections of 120\u00b0 Turns: Group p31m - 272</li> <li>Quarter-Turns: Group p4 - 280</li> <li>Reflections of Quarter-Turns: Group p4gm - 290</li> <li>Reflections in the Sides of a 45\u00b0-45\u00b0-90\u00b0 Triangle: Group p4mm - 302</li> <li>Sixfold Rotations: Group p6 - 314</li> <li>Reflections in the Sides of a 30\u00b0-60\u00b0-90\u00b0 Triangle: Group p6mm - 324</li> <li>Summary - 332</li> </ol> <p>Appendix Derivations and the Absence of Group p5 - 376</p> <p>Bibliography - 392 Index - 394</p>","tags":["Illustrations","Patterns","Frieze Groups","Wallpaper Groups","Symmetry"]},{"location":"books/handbook_of_reg_patterns/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Patterns","Frieze Groups","Wallpaper Groups","Symmetry"]},{"location":"books/how_to_draw_alhambra/","title":"How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela","text":"<p>This is another excellent book about Islamic geometric patterns, focusing on the Alhambra palace in Granada, Spain. It is a how to draw book filled with whole page illustrations with step by step instructions. I have the English version. The book is a treasure trove of information for anyone interested in Islamic art, geometry, or the history of the Alhambra.</p> <p>The book covers almost every room in the Alhambra palace, and it is a great resource for anyone interested in learning the symmetries of the period (the palace built between 1238 and 1358). It is beautifully illustrated with high-quality images and diagrams that help to explain the complex geometric patterns.</p>","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/how_to_draw_alhambra/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Historic Patterns","IGP","Symmetry","How to Draw"]},{"location":"books/humbert/","title":"Islamic Ornamental Design by Claude Humbert","text":"<p>This book has over 1000 hand-drawn illustrations of Islamic patterns. It is a great resource for anyone interested in historic art and design. Each drawing is accompanied by a brief description of the location and date of the original work in English, French, and German. The book is well-organized and easy to navigate, making it a valuable reference for artists, designers, and historians alike.</p> <p>Inside jacket:</p> <p> </p>","tags":["Illustrations","Patterns","Symmetry","Wallpaper Groups","Frieze Groups","History"]},{"location":"books/humbert/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Patterns","Symmetry","Wallpaper Groups","Frieze Groups","History"]},{"location":"books/intro_graph_theory/","title":"Introduction to Graph Theory by  Richard J. Trudeau","text":"<p>This is a classic book on graph theory that provides a comprehensive introduction to the subject. It covers a wide range of topics, including basic concepts, algorithms, and applications. The book is well-written and easy to understand, making it suitable for both beginners and more advanced readers. It includes many examples and exercises to help readers understand the material, and it is a great resource for anyone interested in learning about graph theory.</p>","tags":["Math","Graph Theory"]},{"location":"books/intro_graph_theory/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Math","Graph Theory"]},{"location":"books/paccard_morocco/","title":"Traditional Islamic Craft in Moroccan Architecture (Vol.1 &amp; 2) by Andre Paccard","text":"<p>This is a two-volume set that provides a comprehensive overview of the traditional Islamic craft in Moroccan architecture. The books are filled with high-quality pictures that help to explain the complex geometric patterns and designs found in Moroccan architecture. The author, Andre Paccard, is an expert in the field and has spent many years studying and documenting the intricate details of Moroccan architecture.</p> <p></p> <p> </p>","tags":["Historic Patterns","IGP","Morrocco"]},{"location":"books/paccard_morocco/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Historic Patterns","IGP","Morrocco"]},{"location":"books/space_tessellations/","title":"Space Tessellations: Experimenting with Parquet Deformations by Werner van Hoeydonck (Editor), Christian Kern (Editor), Eva Sommeregger (Editor)","text":"","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/space_tessellations/#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>In Memoriam: William S. Huff (1927\u20132021)     From HfG Ulm to Louis Kahn\u2019s Design Office     From Symmetry to Parquet Deformations with Temporality and Flow D\u00e9nes Nagy</p> </li> <li> <p>Introduction     Werner Van Hoeydonck, Eva Sommeregger</p> </li> </ol>","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/space_tessellations/#research-perspectives","title":"Research Perspectives","text":"<ol> <li> <p>Parquet Deformations: A Subtle, Intricate Art Form - Douglas R. Hofstadter</p> </li> <li> <p>Past and Future of William Huff\u2019s Parquet Deformations - Werner Van Hoeydonck</p> </li> <li> <p>Grundlehre at the HfG \u2014 A Focus on \u201cVisuelle Grammatik\u201d - William S. Huff</p> </li> <li> <p>Geometry of Structures and Its Philosophical Aesthetic Background - Cornelie Leopold</p> </li> <li> <p>The Tiles, They Are a-Changin\u2019 - Craig S. Kaplan</p> </li> <li> <p>Parametric Modeling of Parquet Deformations: A Novel Method for Design and Analysis - Tu\u011frul Yazar</p> </li> <li> <p>Pattern Manipulation through Hinged Tessellations - Jay Bonner</p> </li> <li> <p>Parakeet3D: Algorithmic Re-Envisioning of Geometrical Pattern Morphogenesis - Esmaeil Mottaghi, Arman Khalil Beigi Khameneh</p> </li> </ol>","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/space_tessellations/#teaching-perspectives","title":"Teaching Perspectives","text":"<ol> <li> <p>Presenting the Experiments\u2019 Outcomes - Editor\u2019s Note</p> </li> <li> <p>The Tiling and the Whole - Christian Kern</p> </li> </ol> <p>3D Parquet Deformation</p> <ol> <li> <p>Exercise 1: 2D Parquets, 2D Parquet Deformation</p> </li> <li> <p>Exercise 2: Continuous Deformation</p> </li> <li> <p>Exercise 3: Deformation of the Basic Structure</p> </li> <li> <p>Exercise 4: 3D Parquets, 3D Parquet Deformation</p> </li> <li> <p>Exercise 5: Design Concept</p> </li> <li> <p>Exercise 6: Presentation Model</p> </li> </ol>","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/space_tessellations/#cellular-space-sequences","title":"Cellular Space Sequences","text":"<ol> <li> <p>Exercise 1: Figure Ground</p> </li> <li> <p>Exercise 2: Solid and Void</p> </li> <li> <p>Exercise 3: Composition and Design</p> </li> <li> <p>Exercise 4: Presentation Model</p> </li> </ol>","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/space_tessellations/#additional-sections","title":"Additional Sections","text":"<ol> <li> <p>Epilogue</p> </li> <li> <p>Acknowledgments</p> </li> <li> <p>Imprint</p> </li> </ol>","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/space_tessellations/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Parquet Deformations","Illustrations","Symmetry"]},{"location":"books/the_fascination_of_groups/","title":"The Fascination of Groups by F.J. Budden","text":"<p>This book is the best introduction to group theory I have ever read. It serves as an excellent resource for anyone interested in the mathematics of symmetry and its applications in art and design. Written in a clear and engaging style, it assumes no prior knowledge of group theory. The book is filled with illustrations and examples that effectively clarify the concepts being discussed. While most books on group theory become difficult to read and understand for non-mathematicians after a few chapters, this one stands out\u2014it is well-organized and easy to follow.</p> <p>Internet archive has a copy of the book available for borrowing. You can find it here.</p> <p>Contents</p> <p>Preface xi</p> <p>Notation xvii</p> <ol> <li> <p>Mathematical structure</p> </li> <li> <p>Putting things together: binary operations on a set    Laws of composition: illustrations of binary operations on numbers, on sets, on people, on matrices, on ordered pairs and triples, in geometry. Unary operations. Matrices: a brief summary. Commutative and non-commutative operations. Exercises.</p> </li> <li> <p>Self-contained systems: closure    Binary operations within a set. Illustrations; counter-examples\u2014failure for closure. Closure by including extra elements, or by omitting elements. Exercises.</p> </li> <li> <p>Combined Ops: composition of operations    Composition of geometrical transformations, of functions by successive substitution, of permutations, of matrices. Games with operations. Notation\u2014first operation on the right: juxtaposition\u2014the multiplicative notation. Matrices describing symmetries; permutation matrices. Successive transformations of the points of a circle. Exercises.</p> </li> <li> <p>Associativity    Punctuation in mathematics. Testing for associativity. Examples of operations which are associative, and counter-examples where associativity fails. Associativity of mappings: examples. Exercises.</p> </li> <li> <p>Status Quo: identity elements    Examples of identity elements. Formal definition. Finite arithmetics. Cases when identity elements are obscure. Geometrical examples. Left and right identities. Exercises.</p> </li> <li> <p>As You Were! - Inverses    The idea of inverses\u2014inverse permutations and their dual aspects. Inverses in finite arithmetic and geometric examples. General definition. The operation \u0394 on sets. Solving linear equations and singular matrices.    \\((xy)^{-1} = y^{-1}x^{-1}\\). Exercises.</p> </li> <li> <p>Group Structure    Requirements of a group\u2014definition and examples of finite and infinite groups. Structure tables for finite groups. A group of six permutations. Introduction to groups of symmetries, including the two-group and further symmetry groups. Abelian groups. Groups of two-dimensional transformations. Systems that fail to be groups. Exercises.</p> </li> <li> <p>Properties of Groups    Cancellation laws. The Latin-square property and its proof. Solving equations within groups. Use of Latin-square properties to complete group tables. Cayley's theorem and its verification. Regular representation of finite groups using matrices. Algebra within groups with practical examples. Exercises.</p> </li> <li> <p>Period (Order) of an Element: Permutations and Cycles    Definition and finding the period of an element using group tables. Subgroups generated by single elements. Period of permutations\u2014including cycles and cyclic permutations. Period of disjoint cycles and overlapping cycles. Periods of functions and matrices, including those with complex terms. Infinite period and the infinite cyclic group. Exercises.</p> </li> <li> <p>Carbon Copy Groups: Abstract Groups and Isomorphism    The Klein four-group in thirteen different situations. Abstract groups and isomorphism of finite groups. Identifying different groups of order 4 and order 6. Establishing isomorphisms and their definitions. Infinite group isomorphism. Isomorphisms between additive and multiplicative groups in finite arithmetic. Modular arithmetic slide rules. Automorphisms of \\(C_4\\), \\(D_2\\), and \\(C_6\\). Inner automorphisms and their applications. Exercises.</p> </li> <li> <p>Cyclic Groups    Various realizations of the cyclic group of order 6. Recurring decimals and cyclic groups of prime order. Regular polygons and cyclic groups of composite order. \\(n\\)th roots of unity and the cyclotomic equation. Related problems. The infinite cyclic group. Exercises.</p> </li> <li> <p>The Dihedral Group    Direct and opposite symmetries, including mirror reflections. The full group of the regular hexagon (\\(D_6\\)). Other realizations of \\(D_6\\), \\(D_3\\), and \\(D_4\\). Reflections in intersecting mirrors and kaleidoscope symmetries. The group \\(D_3\\) of the equilateral triangle, isomorphic to \\(S_3\\). Permutations of vertices\u2014fixed and moving axes. Cayley's theorem illustrated with a triangular prism. Subgroups of \\(D_6\\). The general dihedral group of order \\(2n\\): generators and defining relations. The infinite dihedral group. Groups generated by elements of period 2. Exercises.</p> </li> <li> <p>Groups Within Groups: Subgroups    Definition and examples, including Lagrange\u2019s theorem. Cyclic subgroups generated by single elements. Center of a group. Subgroups of \\(S_4\\). Normalizers and centralizers for subgroup identification. Non-cyclic subgroups generated by multiple elements. Subgroups in infinite groups like \\(C_4^+\\), \\(C_x\\), and their transformations. Finite groups of plane transformations and their subgroups. Exercises.</p> </li> <li> <p>Group Specifications: Generators and Defining Relations    Groups requiring multiple generators. Defining relations and their independence. Group of quaternions and dicyclic groups. Cayley diagrams, including the Cayley graph for \\(Q_8\\) (the quaternion group). Additional notes on Cayley diagrams. Exercises.</p> </li> <li> <p>Bigger and Better Groups: Direct Product Groups    Definition and examples, including the construction of new groups like \\(C_6 \\times C_2\\). Associativity and commutativity of direct products, including non-Abelian cases. Periods of elements in direct product groups. The \"packing-case\" group and groups of order 24. Exercises.</p> </li> <li> <p>Catalogue of Groups: Symmetry Groups     Table of all groups of order \\( n \\leq 12 \\). Symmetry groups of two- and three-dimensional figures. The rotation group; enantiomorphs and the full group. Group of the regular tetrahedron; representation by matrices. Cube and octahedron; representation by matrices and by permutations. Icosahedral group \\( A_5 \\); the full group \\( A_5 \\times C_2 \\). Exercises.</p> </li> <li> <p>Permutations     Odd and even permutations \u2013 inversions of order. Change of parity due to a single transposition. Permutations as a product of transpositions. Pairing odd and even permutations \u2013 alternating groups. A set of permutations to represent \\( S_4 \\); two generators only needed. Resolution of a permutation into disjoint cycles. The period of a permutation is the LCM of the lengths of its disjoint cycles. Manipulation of cycles; overlapping cycles. The group of a polynomial. Cross-ratio; the six cross-ratios of four numbers. Exercises.</p> </li> <li> <p>Cosets in Finite and Infinite Groups: Equivalence Classes     Cosets in the group \\( D_4 \\). Reading of cosets from the group table. Interpretation of cosets; illustrations. Preview of normal subgroups. Properties of cosets. Cosets in infinite groups: groups of vectors; of real and complex numbers; of plane transformations. Lagrange\u2019s theorem \u2013 proof. Construction of structure tables. Equivalence relations and equivalence classes; partitioning into disjoint subsets. Cosets as equivalence classes. A binary operation on subsets \u2013 the product set. Product of subsets from infinite and finite groups. Product of cosets. Exercises.</p> </li> <li> <p>Conjugate Elements: Normal Subgroups (1)     The transform of an element. Conjugate elements have the same period. Similar permutations. Reflection in a moved axis; successive reflections in moved axes. Successive rotations about moved vertices. Transformed operations in general; further illustrations. Conjugacy classes; finding conjugacy classes \u2013 the \u2018snap\u2019 method. The transforming element. Conjugacy classes and cosets; centralizers. The transform of a given subgroup; conjugate subgroups. Normal subgroups; methods for determining whether a given subgroup is normal. Normalizer of a subset. Exercises.</p> </li> <li> <p>Homomorphism: Quotient Groups: Normal Subgroups (2)     Homomorphic mappings. Many-to-one mappings in general. Homomorphisms of finite groups. Kernel of a homomorphism. Normal subgroups; groups of cosets; quotient groups. Homomorphic images of Abelian groups. Failure when a subgroup is not normal. Product of cosets of normal subgroups. Quotient (or factor) groups. Quotient groups in direct product groups. Chains of normal subgroups. Simple groups: insolubility of the quintic equation. Proof that \\( A_5 \\) is simple, and that \\( A_5 \\) is the only normal subgroup of \\( S_5 \\). Infinite groups with finite and infinite quotient groups. Summary. Exercises.</p> </li> <li> <p>Automorphisms     Inner and outer automorphisms. Automorphisms of Abelian and non-Abelian groups. Automorphisms of \\( S_5 \\). Proof that inner automorphisms form a normal subgroup of the full automorphism group.</p> </li> <li> <p>Groups and Music     Musical pitch; the octave; musical intervals. The harmonic series. The perfect fifth. The pentatonic scale; the Pythagorean scale; just intonation. Equal temperament; tempered intervals \u2013 the group \\( C_{12} \\). Groups and musical form \u2013 the round, the canon, and the fugue. Imitation, inversion, augmentation, sequences. Exercises.</p> </li> <li> <p>Ringing the Changes: Groups and Campanology     The campanologist\u2019s rules for ringing changes and the principles of composition of methods. Three and four bells. Methods for producing twenty-four changes on four bells using group theory. Five bells \u2013 Stedman Doubles; leads and plain courses, subgroups, and cosets. Six bells; bobs and singles; Plain Bob Minor. Symmetry; other methods.</p> </li> <li> <p>Groups in Geometrical Situations</p> <ul> <li>Dihedral groups on a circle and on a parabola generated by two involutions.</li> <li>Poncelet's porism.</li> <li>Relettering of geometrical configurations.</li> <li>The complete quadrilateral; the orthocentric quadrilateral and the nine-point circle.</li> <li>Pappus' theorem; Pascal's hexagon; Desargues' perspective triangle theorem.</li> <li>Stabilizer subgroups.</li> </ul> </li> <li> <p>Patterns</p> <ul> <li>Patterns obtained by systematic repetition of a motif.</li> <li>The point groups \\(C_n\\) and \\(D_n\\).</li> <li>Analytical and synthetic approaches.</li> <li>Fundamental regions.</li> <li>The seven frieze patterns.</li> <li>Classification of patterns.</li> <li>The two-dimensional (wallpaper) patterns.</li> <li>The twelve plane patterns that contain opposite isometries.</li> <li>Sub-patterns; subgroups of plane patterns; normal subgroups.</li> <li>Exercises.</li> </ul> </li> </ol> <p>Appendices Answers Bibliography Index</p>","tags":["Math","Reference","Group Theory"]},{"location":"books/the_fascination_of_groups/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Math","Reference","Group Theory"]},{"location":"books/the_symmetries_of_things/","title":"The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss","text":"<p>This book is one of the rare books that covers the topic of symmetry in a comprehensive and accessible way. It is written by three experts in the field and includes many illustrations and examples to help readers understand the concepts. The book covers a wide range of topics, including symmetry groups, tilings, colorings of patterns, and the classification of patterns to list a few. It is a great resource for anyone interested in the mathematics of symmetry.</p> <p>While most books approach symmetry primarily through group theory, this one takes a dual perspective, exploring symmetry through both topology and group theory. It serves as an excellent resource for anyone interested in the mathematics of symmetry and its applications in art and design. The book embodies the unique and unmistakable style of the late English mathematician John Horton Conway (December 26, 1937 \u2013 April 11, 2020), renowned for his playful and engaging approach to mathematics.</p>","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/the_symmetries_of_things/#table-of-contents","title":"Table of Contents","text":"","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/the_symmetries_of_things/#part-i-symmetries-of-finite-objects-and-plane-repeating-patterns","title":"Part I: Symmetries of Finite Objects and Plane Repeating Patterns","text":"<ol> <li>Symmetries</li> <li>Planar Patterns</li> <li>The Magic Theorem</li> <li>The Spherical Patterns</li> <li>The Seven Types of Frieze Patterns</li> <li>Why the Magic Theorems Work</li> <li>Euler\u2019s Map Theorem</li> <li>Classification of Surfaces</li> <li>Orbifolds</li> </ol>","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/the_symmetries_of_things/#part-ii-color-symmetry-group-theory-and-tilings","title":"Part II: Color Symmetry, Group Theory, and Tilings","text":"<ol> <li>Presenting Presentations</li> <li>Twofold Colorations</li> <li>Threefold Colorings of Plane Patterns</li> <li>Other Primefold Colorings</li> <li>Searching for Relations</li> <li>Types of Tilings</li> <li>Abstract Groups</li> </ol>","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/the_symmetries_of_things/#part-iii-repeating-patterns-in-other-spaces","title":"Part III: Repeating Patterns in Other Spaces","text":"<ol> <li>Introducing Hyperbolic Groups</li> <li>More on Hyperbolic Groups</li> <li>Archimedean Tilings</li> <li>Generalized Schlafli Symbols</li> <li>Naming Archimedean and Catalan Polyhedra and Tilings</li> <li>The 35 \u201cPrime\u201d Space Groups</li> <li>Objects with Prime Symmetry</li> <li>Flat Universes</li> <li>The 184 Composite Space Groups</li> <li>Higher Still</li> </ol>","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/the_symmetries_of_things/#appendix","title":"Appendix","text":"<ul> <li>Other Notations for the Plane and Spherical Groups</li> </ul>","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/the_symmetries_of_things/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Math","Reference","Patterns","Tilings","Illustrations","Frieze Groups","Wallpaper Groups","Color Symmetry","Hyerbolic Tilings"]},{"location":"books/tilings_and_patterns/","title":"Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2<sup>nd</sup> Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard","text":"<p>This is the second edition of the classic book on tilings and patterns, which includes a wealth of information on the mathematical theory behind these concepts. It covers a wide range of topics, including symmetry, group theory, and the classification of tilings. The book is well-illustrated and includes many examples and exercises to help readers understand the material.</p> <p>Any material by Gr\u00fcnbaum or Shepard is worth reading. They are both highly respected mathematicians and have made significant contributions to the field of tilings and patterns. Their work is often cited in the literature, and their books are considered essential reading for anyone interested in this area of mathematics.</p>","tags":["Math","Reference","Patterns","Tilings","Illustrations"]},{"location":"books/tilings_and_patterns/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Preface to the Dover Edition</li> <li>Preface</li> <li>Introduction</li> <li>Basic Notions</li> <li>Tilings by Regular Polygons and Star Polygons</li> <li>Well-Behaved Tilings</li> <li>The Topology of Tilings</li> <li>Patterns</li> <li>Classifications of Tilings with Transitivity Properties</li> <li>Classification with Respect to Symmetries</li> <li>Colored Patterns and Tilings</li> <li>Tilings by Polygons</li> <li>Aperiodic Tilings</li> <li>Wang Tiles</li> <li>Tilings with Unusual Kinds of Tiles</li> <li>Appendix</li> <li>References</li> <li>Index</li> </ol>","tags":["Math","Reference","Patterns","Tilings","Illustrations"]},{"location":"books/tilings_and_patterns/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Math","Reference","Patterns","Tilings","Illustrations"]},{"location":"books/topkapi_scroll/","title":"The Topkapi Scroll: Geometry and Ornament in Islamic Architecture by G\u00fclru Necipo\u011flu","text":"<p>Excerpt from the publisher's site with free access to the book:</p> <p>\"Since precious few architectural drawings and no theoretical treatises on architecture remain from the premodern Islamic world, the Timurid pattern scroll in the collection of the Topkapi Palace Museum Library is an exceedingly rich and valuable source of information. In the course of her in-depth analysis of this scroll dating from the late fifteenth or early sixteenth century, G\u00fclru Necipo\u011flu throws new light on the conceptualization, recording, and transmission of architectural design in the Islamic world between the tenth and sixteenth centuries. Her text has particularly far-reaching implications for recent discussions on vision, subjectivity, and the semiotics of abstract representation. She also compares the Islamic understanding of geometry with that found in medieval Western art, making this book particularly valuable for all historians and critics of architecture.</p> <p>The scroll, with its 114 individual geometric patterns for wall surfaces and vaulting, is reproduced entirely in color in this elegant, large-format volume. An extensive catalogue includes illustrations showing the underlying geometries (in the form of incised \u201cdead\u201d drawings) from which the individual patterns are generated. An essay by Mohammad al-Asad discusses the geometry of the muqarnas and demonstrates by means of CAD drawings how one of the scroll\u2019s patterns could be used co design a three-dimensional vault.\"</p>","tags":["Historic Patterns","IGP"]},{"location":"books/topkapi_scroll/#table-of-contents","title":"Table of Contents","text":"<p>Preface</p> <p>Notes to the Reader</p> <p>Part 1: The Scroll Tradition</p> <p>Chapter 1. Architectural Drawings and Scrolls in the Islamic World</p> <p>Chapter 2. The Topkapi Scroll, Its Date and Provenance</p> <p>Chapter 3. The Topkapi Scroll as a Mirror of Late Timurid-Turkmen Architectural Practice</p> <p>Notes to Part 1</p> <p>Part 2: The Discourse on the Geometric \u201cArabesque\u201d</p> <p>Chapter 4. Ornamentalism and Orientalism: The Nineteenth- and Early Twentieth-Century European Literature</p> <p>Chapter 5. Recent Studies on Geometric Ornament</p> <p>Notes to Part 2</p> <p>Part 3: The Geographical, Chronological, and Semantic Horizons of the Geometric Mode</p> <p>Chapter 6. Geometric Patterning Before the Mongols</p> <p>Chapter 7. The Post-Mongol Synthesis</p> <p>Notes to Part 3</p> <p>Part 4: Geometry and the Contribution of Mathematical Sciences</p> <p>Chapter 8. Theory and Praxis: Uses of Practical Geometry</p> <p>Chapter 9. Manuals of Practical Geometry and the Scroll Tradition</p> <p>Notes to Part 4</p> <p>Part 5: Geometry and Aesthetic Theory</p> <p>Chapter 10. The Aesthetics of Proportion and Light</p> <p>Chapter 11. Geometric Abstraction and the Psychology of Visual Perception</p> <p>Chapter 12. The Semiotics of Ornament</p> <p>Notes to Part 5</p> <p>Catalog: Pattern Types and Drawings in the Topkapi Scroll</p> <p>List of Pattern Types</p> <p>List of Drawings</p> <p>The Topkapi Scroll: A Color Reproduction</p> <p>The Muqarnas: A Geometric Analysis by Mohammad al-Asad</p> <p>Map of the Islamic World</p> <p>Bibliography of Printed Primary and Secondary Sources</p> <p>Index</p>","tags":["Historic Patterns","IGP"]},{"location":"books/topkapi_scroll/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Historic Patterns","IGP"]},{"location":"books/visions/","title":"M.C. Escher : Visions of Symmetry by Doris Schattschneider","text":"<p>This book documents the evolution of Escher's work and the mathematical ideas that inspired him. It has very interesting details about the artist's life and work, and parallels between his work and the work of the mathematicians who were active in the same period.</p> <p>Escher's \"Regular Division of the Plane\" (Regelmatige Vlakverdeling in Dutch)is presented in its entirety, and the book provides a good overview of the mathematical concepts behind it. The author, Doris Schattschneider, spent more than 15 years to research and write this book, and it shows.</p> <p>This is the second edition of the book. It is identical to the first edition with the exception of the 20 page <code>Afterword</code> which covers more recent developments about Escher's work.</p> <p></p>","tags":["Illustrations","Patterns","Symmetry","Wallpaper Groups","Escher"]},{"location":"books/visions/#categories","title":"Categories","text":"<ul> <li>Books</li> </ul>","tags":["Illustrations","Patterns","Symmetry","Wallpaper Groups","Escher"]},{"location":"a-simple-triangle-shape/","title":"A simple triangle shape","text":"","tags":["S\u0130METR\u0130 Basics"]},{"location":"a-simple-triangle-shape/#tutorial-a-simple-triangle-shape","title":"Tutorial: A simple triangle shape","text":"","tags":["S\u0130METR\u0130 Basics"]},{"location":"a-simple-triangle-shape/#interface","title":"Interface","text":"<ul> <li>Click on the plus signs () to see the   comments about the corresponding line of code.</li> <li>You can also click on the copy icon located at the upper right   corner to copy the code to your clipboard.</li> <li>Clicking on the images will open them.</li> <li>Graphic output of the scripts are shown next to or below   the code snippets.</li> <li>Some examples may have more then one script in the same block.   These are presented in a tabbed format. You can click on the   tabs to see the other scripts.</li> </ul> Triangle<pre><code>import simetri.graphics as sg # (1)!\n\ncanvas = sg.Canvas() # (2)!\ncanvas.help_lines(pos=(-50, -50), width=300, height=300, spacing=25)\n\npoints = [(25, 25), (50, 75), (100, 0)] # (3)!\ntriangle = sg.Shape(points) # (4)!\ncanvas.draw(triangle, line_width=2) # (5)!\n\ntriangle2 = sg.Shape([(25, 125), (50, 175), (100, 100)], closed=True)\ncanvas.draw(triangle2, fill=False, line_dash_array=[5, 3, 2, 3])\ntriangle2.translate(dx=100, dy=0)\ncanvas.draw(triangle2, line_width=2)\n\ntriangle2.fill_color = sg.amber\ntriangle2.rotate(-sg.pi/4) # (6)!\ncanvas.draw(triangle2, line_width=2)\ncanvas.display() # (7)!\n</code></pre> <ol> <li> <p>Always import the library like this!</p>    And never use <code>from simetri import *</code> since it may create a lot of problems! Your namespace    will be polluted    and debugging will be very difficult. </li> <li> <ul> <li>We do not need to specify <code>size</code> for the canvas. It will be automatically computed if it is not used.</li> <li><code>canvas = sg.Canvas(back_color=sg.yellow)</code> can be used to set the background color.</li> <li><code>canvas</code> is the conventional variable name for the <code>Canvas</code> instances but you can use any valid variable name.</li> </ul> </li> <li> <p>Points</p> <ul> <li>Points can be any sequence of (x, y) or (x, y, 1) values.         [(10, 20), (30, 40), ...], ([15.5, 20., 1], [35, 40, 1], ...) are all valid.</li> <li><code>simetri</code> internally converts them to floating point <code>numpy</code>arrays.</li> <li>The units for cooordinates is <code>pnts</code>. <code>72pnts = 1in</code></li> <li>Point sizes should be reasonable. If a shape is too large to fit into a page or        too small to see clearly, we may have numerical problems.</li> </ul> </li> <li> By default <code>shape.closed = False</code> unless the start and end points are equivalent.  <code>sg.Shape(points, closed=True)</code> can be used to create a closed shape. </li> <li> The default value for <code>shape.line_width = 1</code> but <code>canvas.draw()</code> can overwrite any style attributes. </li> <li> All angles in S\u0130METR\u0130 is counterclockwise positive and in radians. To convert between radians and angles, you can use <code>sg.radians(angle)</code> and <code>sg.degrees(angle)</code> utility functions to convert an angle from degrees to radians and from radians to degrees respectively. </li> <li> You can use <code>canvas.save(\"/your/path/here.pdf\")</code> or in Windows <code>canvas.save(\"c:/your/path/here.svg\")</code> to generate an output file. The supported formats are: <code>.tex</code>, <code>.pdf</code>, <code>.svg</code>, <code>.ps</code>, <code>.eps</code>, and <code>.png</code>. You can also use the <code>show</code> flag to show the output in a web-browser (the default value for <code>show</code> is <code>True</code>). Only <code>.pdf</code>, <code>.svg</code>, and <code>.png</code> files can be shown) You can use the <code>overwrite</code> flag to overwrite any existing files.  <code>canvas.save(\"/your/path/here.pdf\", show=False, overwrite=True</code>) </li> </ol> <p></p>","tags":["S\u0130METR\u0130 Basics"]},{"location":"a-simple-triangle-shape/#categories","title":"Categories","text":"<ul> <li>Tutorials</li> </ul>","tags":["S\u0130METR\u0130 Basics"]},{"location":"topics/animation/","title":"Animation","text":""},{"location":"topics/batches/","title":"Batches","text":""},{"location":"topics/batches/#batch-objects","title":"Batch Objects","text":"<p><code>Batch</code> objects along with the <code>Shape</code> objects are the main building blocks of S\u0130METR\u0130. They are used to group multiple shapes, paths, and other <code>Batch</code> objects together, allowing for complex designs to be created easily. A <code>Batch</code> object can contain other <code>Batch</code> objects, enabling a hierarchical structure for organizing shapes and patterns.</p> <p>As the name suggests, <code>Batch</code> objects can be used to modify its elements all at once. For example, you can change the color of all shapes in a <code>Batch</code> object with a single command. For example; <code>batch.set_attribs('fill_color', sg.red)</code> will change the fill color of all shapes in the <code>Batch</code> object to red.</p> <p><code>Batch</code> objects have no style properties. They are used to group shapes and other <code>Batch</code> objects together. The <code>Batch</code> object itself does not have any visual identity itself, but it can be used to apply transformations and styles to the shapes it contains.</p> <p><code>Batch</code> objects have bounding-boxes, which are used to define the area that the <code>Batch</code> object occupies. The bounding-box of a <code>Batch</code> object is the smallest rectangle that can enclose all the shapes and other <code>Batch</code> objects it contains. The bounding-box can be used as reference points/lines to apply transformations to the <code>Batch</code> object as a whole.</p> <p><code>Batch</code> objects behave like Python lists and sets. See the List Operations and Set Operations sections for more details. These operations make <code>Batch</code> objects very flexible and powerful for creating complex designs while keeping the data structure simple and easy to use. Most objects in S\u0130METR\u0130 and its extensions inherit from <code>Shape</code> and <code>Batch</code> classes.</p> <p></p> <p>The Structure of <code>Batch</code> objects.</p> <p>Batch objects can contain other Batch objects.</p>"},{"location":"topics/batches/#creating-a-batch-object","title":"Creating a Batch Object","text":"<p><code>Batch</code> objects can be created using the <code>Batch</code> class. They can be initialized with no arguments, with a single item, or a list of items. The items can be any object, including other <code>Batch</code> objects. The following example shows how to create a <code>Batch</code> object with a variety of items:</p> <pre><code>import simetri.graphics as sg\n\nshape1 = sg.Shape()\nshape2 = sg.Shape()\nshape3 = sg.Shape()\n\nbatch1 = sg.Batch()\nbatch2 = sg.Batch(shape1)\nbatch3 = sg.Batch([batch2, shape2, shape3])\n</code></pre>"},{"location":"topics/batches/#implicitly-creating-a-batch-object","title":"Implicitly Creating a Batch Object","text":"<p>When we transform a <code>Shape</code> object with repetitions, a <code>Batch</code> object is implicitly created. For example, when we use the <code>Shape.rotate</code> method with repetitions, a <code>Batch</code> object is created to hold the rotated shapes. The following example shows how this works:</p> <pre><code>&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; shape = sg.Shape([(0, 0), (100, 100)])\n&gt;&gt;&gt; shapes = shape.rotate(sg.pi/6, reps=5)\n&gt;&gt;&gt; shapes.type\n&lt;Types.BATCH: 'BATCH'&gt;\n&gt;&gt;&gt; len(shapes)\n6\n&gt;&gt;&gt;\n</code></pre> <p>When we transform a <code>Batch</code> object with multiple repetitions, this operation does not yield a new <code>Batch</code> object. Instead, the original <code>Batch</code> object is modified in place (the transformed objects are appended to the <code>Batch</code>). The following example shows how this works:</p> <pre><code>&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; shape = sg.Shape([(0, 0), (100, 100)])\n&gt;&gt;&gt; batch = sg.Batch(shape)\n&gt;&gt;&gt; batch.translate(100, 0, reps=3)\nBatch(Shape(((0.0, 0.0), (100.0, 100.0)))...Shape(((300.0, 0.0), (400.0, 100.0))))\n&gt;&gt;&gt; len(batch)\n4\n&gt;&gt;&gt;\n</code></pre> <p>Transformations with zero repetitions modify the original <code>Shape</code>/<code>Batch</code> object without generating new items.</p> <p>This allow us to apply consecutive transformations via method chaining to the same <code>Batch</code> object without having to handle the intermediate results. For example, we can rotate and translate a <code>Batch</code> object in a single command:</p> <pre><code>&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; shape = sg.Shape([(0, 0), (100, 100)])\n&gt;&gt;&gt; batch = sg.Batch(shape)\n&gt;&gt;&gt; batch.rotate(sg.pi/6, reps=5).translate(100, 0, reps=3)\nBatch(Shape(((0.0, 0.0), (100.0, 100.0)))...Shape(((300.0, 0.0), (163.3974596215561, -36.60254037844381))))\n&gt;&gt;&gt; len(batch)\n24\n&gt;&gt;&gt;\n</code></pre> <p>In S\u0130METR\u0130, some operations (transformations, canvas.draw, etc.) can be chained together.</p>"},{"location":"topics/batches/#batch-object-properties","title":"Batch Object Properties","text":"<p><code>Batch</code> objects have the following properties:</p> id The id of the <code>Batch</code> object. This is a unique identifier (positive integer) for the <code>Batch</code> object, created during its construction. active The active state of the <code>Batch</code> object. This is a boolean value that indicates whether the <code>Batch</code> object is active or not. If the <code>Batch</code> object is active and visible, it will be displayed on the canvas when drawn. <p>When a <code>Batch</code> object is not active, it cannot be transformed.</p> visible The visibility state of the <code>Batch</code> object. This is a boolean value that indicates whether the <code>Batch</code> object is visible or not. If the <code>Batch</code> object is not visible, it will not be displayed on the canvas when drawn. all_elements Return a list of all elements in the batch, including the elements in the nested batches. all_shapes Return a list of all shapes in the batch, including the shapes in the nested batches. all_vertices Return a list of aggregated list of all vertices from all <code>Shape</code> objects in the batch, including the shapes in the nested batches. all_segments Return a list of all segments in the batch, including the segments in the nested batches. ids Return a list of all unique ids of the items in the batch. If the element does not have an <code>id</code> attribute then <code>id(item)</code> will be used. all_ids Return a list of all unique ids of the items in the batch, including the items in the nested batches. If the element does not have an <code>id</code> attribute then <code>id(item)</code> will be used. This is similar to <code>ids</code> but it returns a list of all ids, including duplicates."},{"location":"topics/batches/#list-operations","title":"List Operations","text":"<p><code>Batch</code> objects are similar to Python lists. They can be used as lists and have similar methods. The main difference is that <code>Batch</code> objects can only contain unique items. If you try to add an item that already exists in the <code>Batch</code>, it will raise a warning message. The following methods are available for <code>Batch</code> objects:</p> append(item) Add an item to the end of the items. It will fail (will trigger a warning message, it doesn't raise an error) if this would cause redundant items in the Batch object. The item can be any object. clear() Remove all items from the <code>Batch</code>. copy() Return a copy of the <code>Batch</code> object. Not just the items but the whole <code>Batch</code> object will be copied. count(item) Since all items are unique, count will return either 1 or 0. It doesn't check for equivalence of the items, it checks for identical objects. It will return 1 if there is an item with the same <code>id</code>. extend() Add items from another sequence of items to the end of the items. It will raise a warning if this would cause redundant items in the <code>Batch</code> object. Identical items will be ignored. index(item, start=0, end=None) Return the index of the first occurrence of a specified item. It will raise a <code>ValueError</code> if the item is not found. The <code>start</code> and <code>end</code> arguments are optional and can be used to specify a range in which to search for the item. insert(index, item) Insert an item at a specified position. It will fail if this would cause redundant items in the <code>Batch</code> object. pop(ind=-1) Remove and return the item at the specified position (or the last item if no index is specified). remove(item) Remove the first occurrence of a specified item. It will raise a <code>ValueError</code> if the item is not found. reverse() Reverse the order of the items. sort(key, reverse=False) Sort the items in ascending order (by default) or in descending order by setting the <code>reverse</code> argument to be True. <code>key</code> is a function that takes an (item) as an argument and returns a value that will be used for sorting. Unlike Python's sort method the key argument is not optional."},{"location":"topics/batches/#indexing-and-slicing","title":"Indexing and Slicing","text":"<p><code>Batch</code> objects support indexing and slicing. You can access individual items or a range of items using Python's indexing and slicing syntax:</p> <pre><code>&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; batch = sg.Batch()\n&gt;&gt;&gt; batch.append(sg.Shape([(0, 0), (100, 100)]))\n&gt;&gt;&gt; batch.append(sg.Shape([(100, 100), (200, 200)]))\n&gt;&gt;&gt; batch.append(sg.Shape([(200, 200), (300, 300)]))\n&gt;&gt;&gt; batch[0] # Access the first item\nShape(((0.0, 0.0), (100.0, 100.0)))\n&gt;&gt;&gt; batch[1:] # Access the second and third item\nShape(((100.0, 100.0), (200.0, 200.0))), Shape(((200.0, 200.0), (300.0, 300.0)))\n&gt;&gt;&gt;\n</code></pre>"},{"location":"topics/batches/#set-operations","title":"Set Operations","text":"<p><code>Batch</code> objects can be used as sets (<code>batch.ids</code> is used for hashing). Items are compared using their <code>id</code> attributes. If the item does not have an <code>id</code> attribute then <code>id(item)</code> will be used. This means that two items with the same content but different ids will be considered as distinct items.</p> <p>The following methods are available for <code>Batch</code> objects:</p> union(other: Batch) Return a new <code>Batch</code> object that contains all the items from both <code>Batch</code> objects. If there are any duplicate items, they will be removed. intersection(other: Batch) Return a new <code>Batch</code> object that contains the items that are present in both <code>Batch</code> objects. difference(other: Batch) Return a new <code>Batch</code> object that contains the items that are present in the first <code>Batch</code> object but not in the second <code>Batch</code> object. symmetric_difference(other: Batch) Return a new <code>Batch</code> object that contains the items that are present in either <code>Batch</code> object but not in both. issubset(other: Batch) Return True if the first <code>Batch</code> object is a subset of the second <code>Batch</code> object, otherwise return False. issuperset(other: Batch) Return True if the first <code>Batch</code> object is a superset of the second <code>Batch</code> object, otherwise return False. isdisjoint(other: Batch) Return True if the two <code>Batch</code> objects have no items in common, otherwise return False."},{"location":"topics/batches/#batch-objects-additional-methods","title":"Batch Objects' Additional Methods","text":"<p>In addition to the methods mentioned above, <code>Batch</code> objects have the following additional methods:</p> merge_shapes() -&gt; Batch Merge all shapes in the batch into a single shape where possible. This is useful for creating complex shapes from simpler ones. This does not modify the batch object or the shapes in it. It returns a new <code>Batch</code> object that contains the merged shapes. set_attribs(attrib: str, value: Any, key: callable=None) -&gt; Self <p>Set the specified attribute for all applicable items in the batch. The attribute can be any attribute of the items in the batch, if an item doesn't have the given attribute then it will be ignored. This is useful for applying a common attribute to all items in the batch.</p> <p>If the optional <code>key</code> argument is provided, it should be a callable that takes an item as an argument and returns a boolean value. The attribute will only be set for items that return True when passed to the <code>key</code> function.</p> <p>For example, if you want to set the fill color of all shapes in the batch with more than 4 vertices, you can use the following code: <pre><code>batch.set_attribs('fill_color', sg.red, key=lambda item: len(item) &gt; 4)\n</code></pre> This will set the fill color of all shapes in the batch with more than 4 vertices to red.</p>"},{"location":"topics/batches/#batches-as-iterators","title":"Batches as Iterators","text":"<p><code>Batch</code> objects can be used as iterators. This means that you can use them in a for loop or any other context that requires an iterable object. The following example shows how to use a <code>Batch</code> object as an iterator:</p> <pre><code>&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; batch = sg.Batch()\n&gt;&gt;&gt; batch.append(sg.Shape([(0, 0), (100, 100)]))\n&gt;&gt;&gt; batch.append(sg.Shape([(100, 100), (200, 200)]))\n&gt;&gt;&gt; batch.append(sg.Shape([(200, 200), (300, 300)]))\n&gt;&gt;&gt; for item in batch:\n...     print(item)\n...\n...Shape(((0.0, 0.0), (100.0, 100.0)))\n...Shape(((100.0, 100.0), (200.0, 200.0)))\n...Shape(((200.0, 200.0), (300.0, 300.0)))\n&gt;&gt;&gt; for item in batch:\n...     item.fill_color = sg.red\n...     item.line_color = sg.blue\n&gt;&gt;&gt;\n</code></pre>"},{"location":"topics/batches/#bounding-box-of-a-batch-object","title":"Bounding Box of a Batch Object","text":"<p><code>Batch</code> objects have bounding-boxes, which are used to define the area that the <code>Batch</code> object occupies. The bounding-box of a <code>Batch</code> object is the smallest rectangle that can enclose all the shapes and other <code>Batch</code> objects it contains. The bounding-box can be used as reference points/lines to apply transformations to the <code>Batch</code> object as a whole. For more information about bounding-boxes, see the Bounding Box section.</p> <p></p> <p><code>width</code>, <code>height</code>, and <code>size</code> are not aliases.</p> <p>Since some objects have these properties, we cannot use the same names as aliases. To access these properties, we need to use the <code>b_box</code> property.</p> <pre><code>    batch.b_box.width\n    batch.b_box.height\n    batch.b_box.size\n</code></pre>"},{"location":"topics/bounding_boxes/","title":"Bounding-boxes","text":""},{"location":"topics/bounding_boxes/#bounding-boxes","title":"Bounding-Boxes","text":""},{"location":"topics/bounding_boxes/#working-with-bounding-boxes","title":"Working With Bounding-Boxes","text":"<p>Bounding-boxes are rectangles that enclose a shape or batch object. They provide reference points and lines that can be used for applying transformations (mirror lines, glide lines, centers of rotations, etc). They provide methods to define offset points and lines as well.</p> <p></p> <p>Properties and methods of <code>BoundingBox objects</code>.</p>"},{"location":"topics/bounding_boxes/#aliases","title":"Aliases","text":"<p>The bounding-box of a shape or batch object can be accessed through the <code>b_box</code> property. The bounding-box is an instance of the <code>BoundingBox</code> class, which provides methods and properties for working with bounding-boxes.</p> <p>S\u0130METR\u0130 provides a few aliases for Shape and Batch objects to access the bounding-box properties and methods. The following aliases are available:</p> <code>item.midpoint -&gt; item.b_box.midpoint</code>: Middle point of the bounding-box. <code>item.north -&gt; item.b_box.north</code>: Middle point of the top edge of the bounding-box. <code>item.south -&gt; item.b_box.south</code>: Middle point of the bottom edge of the bounding-box. <code>item.east -&gt; item.b_box.east</code>: Middle point of the right edge of the bounding-box. <code>item.west -&gt; item.b_box.west</code>: Middle point of the left edge of the bounding-box. <code>item.northwest -&gt; item.b_box.northwest</code>: Top left corner of the bounding-box. <code>item.northeast -&gt; item.b_box.northeast</code>: Top right corner of the bounding-box. <code>item.southwest -&gt; item.b_box.southwest</code>: Bottom left corner of the bounding-box. <code>item.southeast -&gt; item.b_box.southeast</code>: Bottom right corner of the bounding-box. <code>item.top -&gt; item.b_box.top</code>: Top edge of the bounding-box. <code>item.bottom -&gt; item.b_box.bottom</code>: Bottom edge of the bounding-box. <code>item.left -&gt; item.b_box.left</code>: Left edge of the bounding-box. <code>item.right -&gt; item.b_box.right</code>: Right edge of the bounding-box. <code>item.bbox_width -&gt; item.b_box.width</code>: Width of the bounding-box. <code>item.bbox_height -&gt; item.b_box.height</code>: Height of the bounding-box. <code>item.bbox_size -&gt; item.b_box.size</code>: <code>(width, height)</code> Size of the bounding-box. <p></p> <p><code>width</code>, <code>height</code>, and <code>size</code> are not aliases.</p> <p>Since some objects have these properties, we cannot use the same names as aliases. To access these properties, we need to use the <code>b_box</code> property.</p> <pre><code>    shape.b_box.width\n    shape.b_box.height\n    shape.b_box.size\n</code></pre>"},{"location":"topics/bounding_boxes/#relative-positioning","title":"Relative Positioning","text":"<p>When we need to position two items relative to each other, we can use the bounding-box of one item to position the other. The bounding-box of a shape or batch object is accessible through the <code>b_box</code> property.</p> <p>The following methods are available for positioning items relative to each other:</p> <p><code>item.b_box</code>:</p> <code>item.centered(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item centered on the other item. <code>item.above(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item above the other item. <code>item.below(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item below the other item. <code>item.left_of(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item to the left of the other item. <code>item.right_of(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item to the right of the other item. <code>item.above_left(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item above and to the left of the other item. <code>item.above_right(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item above and to the right of the other item. <code>item.below_left(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item below and to the left of the other item. <code>item.below_right(other: Shape | Batch, dx: float=0, dy: float=0)</code> Position of the item below and to the right of the other item. <p>These relative positions can be used with <code>dx</code> and <code>dy</code> offsets.</p> <p>The following example shows how to use the bounding-box of a shape to position another shape relative to it.</p> <p><pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\ncanvas.back_color = sg.Color(254, 255, 255)\n\nhex = sg.reg_poly_shape((0, 0), 6, 150)\nrect = sg.Rectangle((0, 0), 220, 70)\npositions = ['centered', 'right_of', 'left_of', 'below_left', 'below_right',\n             'above_right', 'above_left', 'above', 'below']\ncanvas.draw(hex.b_box)\ncanvas.draw(hex, fill_color=sg.teal, line_width=2)\nfor position in positions:\n    pos = getattr(rect, position)(hex)\n    canvas.draw(rect, pos=pos, fill_color=sg.white, line_width=2)\n    canvas.text(f\"rect.{position}(hex)\", pos, font_family=sg.FontFamily.MONOSPACE,\n                font_size=sg.FontSize.LARGE2)\n\ncanvas.display()\n</code></pre> </p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nF = sg.letter_F(back_style=sg.BackStyle.SHADING,\n                shade_type=sg.ShadeType.COLORWHEEL)\n\nletters = F.mirror(F.right, reps=1)\nletters.rotate(angle=sg.pi, about=letters.southeast, reps=1)\n\ncanvas.draw(letters)\ncanvas.display()\n</code></pre> <p></p>"},{"location":"topics/canvas/","title":"Canvas","text":""},{"location":"topics/canvas/#canvas","title":"Canvas","text":"<p>Canvas objects provide a way to draw and manipulate graphics in a 2D space. They are used to create images, shapes, and other visual elements. The canvas can be thought of as a blank sheet of paper where you can draw graphics objects.</p>"},{"location":"topics/canvas/#initialization","title":"Initialization","text":"<p>Canvas objects are created using the <code>Canvas</code> class. They can be initialized with no arguments. When we use the <code>Canvas.save</code> method, the canvas object automatically computes the appropriate size by using the dimensions of the drawn objects and the <code>canvas.border</code> property (which specifies the page margins).</p>"},{"location":"topics/canvas/#drawing","title":"Drawing","text":"<p><code>Canvas.draw</code> method is used to draw graphics objects on the canvas. The <code>draw</code> method takes a drawable object as an argument and draws it on the canvas.</p>"},{"location":"topics/canvas/#overwriting-object-properties","title":"Overwriting Object Properties","text":""},{"location":"topics/canvas/#output-format","title":"Output Format","text":""},{"location":"topics/canvas/#help-lines","title":"Help-lines","text":""},{"location":"topics/canvas/#transformations","title":"Transformations","text":"<p>Canvas objects can be transformed by using transformation methods. This is similar to the <code>Shape</code> and <code>Batch</code> objects. The transformations are applied to the canvas itself, which means that all subsequent drawing operations will be affected by the applied transformation.</p>"},{"location":"topics/canvas/#resetting-the-canvas","title":"Resetting the Canvas","text":""},{"location":"topics/canvas/#resetting-the-transformation-matrix","title":"Resetting the Transformation Matrix","text":""},{"location":"topics/canvas/#clipping","title":"Clipping","text":""},{"location":"topics/canvas/#multiple-page-output","title":"Multiple-page Output","text":""},{"location":"topics/canvas/#jupyter-notebooks","title":"Jupyter Notebooks","text":""},{"location":"topics/canvas/#rendering-pipeline","title":"Rendering Pipeline","text":"<pre><code>flowchart LR\n    A1@{shape: odd, label: \"canvas.draw( )\"}\n    B@{shape: processes, label: \"Sketch Objects\"}\n    C@{shape: odd, label: \"canvas.save(B)\"}\n    D@{shape: odd, label: \"canvas.save(A)\"}\n    E@{shape: notch-rect, label: \"TeX code\"}\n    F@{shape: notch-rect, label: \"TeX code\"}\n    G@{shape: hex, label: \"XeLaTeX\n                            (compile)\"}\n    H@{shape: hex, label: \"XeLaTeX\n                            (compile)\"}\n    I@{shape: doc, label: \"output\n        .pdf, .ps, .eps,\n        .svg, .png, .tex\"}\n    J@{shape: doc, label: \"output\n        .pdf, .ps, .eps,\n        .svg, .png, .tex\"}\n    K@{shape: curv-trap, label: \"display\"}\n    L@{shape: curv-trap, label: \"display\"}\n    A1 --&gt; B --&gt; C\n    A1 --&gt; B --&gt; D\n    subgraph ide1 [ ]\n    C --&gt; E --&gt; G --&gt; I --&gt; K\n    end\n    subgraph ide2 [ ]\n    D --&gt; F --&gt; H --&gt; J --&gt; L\n    end</code></pre>"},{"location":"topics/color_chart/","title":"Named colors in simetri.graphics","text":""},{"location":"topics/colors/","title":"Colors","text":""},{"location":"topics/colors/#colors","title":"Colors","text":""},{"location":"topics/colors/#named-colors","title":"Named-colors","text":"<p>S\u0130METR\u0130 provides a comprehensive list of colors that can be used in your designs. These colors can be accessed by using <code>sg.color_name</code>. The chart of all available named-colors is shown below.</p> <p>These names come from the <code>xkcd color survey</code></p> <p>The colors are defined in the CSS Color Module Level 4 specification. The list is not exhaustive, and you can always define your own colors using RGB or HEX values.</p> <p></p>"},{"location":"topics/colors/#colorsys-conversions-between-color-systems-from-python-3133-documentation","title":"colorsys -- Conversions between color systems (from Python 3.13.3 documentation)","text":"<p>colorsys \u2014 Conversions between color systems Source code: Lib/colorsys.py</p> <p>The colorsys module defines bidirectional conversions of color values between colors expressed in the RGB (Red Green Blue) color space used in computer monitors and three other coordinate systems: YIQ, HLS (Hue Lightness Saturation) and HSV (Hue Saturation Value). Coordinates in all of these color spaces are floating-point values. In the YIQ space, the Y coordinate is between 0 and 1, but the I and Q coordinates can be positive or negative. In all other spaces, the coordinates are all between 0 and 1.</p> <p>See also More information about color spaces can be found at https://poynton.ca/ColorFAQ.html and https://www.cambridgeincolour.com/tutorials/color-spaces.htm. The colorsys module defines the following functions:</p> colorsys.rgb_to_yiq(r, g, b) Convert the color from RGB coordinates to YIQ coordinates. colorsys.yiq_to_rgb(y, i, q) Convert the color from YIQ coordinates to RGB coordinates. colorsys.rgb_to_hls(r, g, b) Convert the color from RGB coordinates to HLS coordinates. colorsys.hls_to_rgb(h, l, s) Convert the color from HLS coordinates to RGB coordinates. colorsys.rgb_to_hsv(r, g, b) Convert the color from RGB coordinates to HSV coordinates. colorsys.hsv_to_rgb(h, s, v) Convert the color from HSV coordinates to RGB coordinates. <p>Example:</p> <pre><code>&gt;&gt;&gt; import colorsys\n&gt;&gt;&gt; colorsys.rgb_to_hsv(0.2, 0.4, 0.4)\n(0.5, 0.5, 0.4)\n&gt;&gt;&gt;colorsys.hsv_to_rgb(0.5, 0.5, 0.4)\n(0.2, 0.4, 0.4)\n&gt;&gt;&gt;\n</code></pre>"},{"location":"topics/conventions/","title":"Conventions","text":""},{"location":"topics/conventions/#conventions","title":"Conventions","text":""},{"location":"topics/conventions/#coordinates","title":"Coordinates","text":"<p>S\u0130METR\u0130 uses Cart\u00e9sian coordinates to define geometry. Origin is located at the lower-left corner with the positive x direction pointing rightward and positive y direction pointing upwards.</p> <p>All angles are in radians and measured from the positive x-axis in counterclockwise positive direction.</p> <ul> <li><code>sg.radians(degrees) -&gt; float</code> converts from degrees to radians.</li> <li><code>sg.degrees(radians) -&gt; float</code> converts from radians to degrees.</li> <li><code>sg.angle(point: Point) -&gt; float</code> returns the angle of the vector from the origin to the point <code>(x, y)</code> in radians.</li> <li><code>sg.line_angle(start: Point, end: Point) -&gt; float</code> returns the angle of the line from <code>start</code> to <code>end</code> in radians.</li> </ul> <p>There are utility functions to convert from/to polar-coordinates.</p> <ul> <li><code>sg.polar_to_cartesian(r: float, theta: float) -&gt; Point[float, float]</code> converts from polar coordinates to Cart\u00e9sian coordinates.</li> <li><code>sg.cartesian_to_polar(x: float, y: float) -&gt; Point[float, float]</code> converts from Cart\u00e9sian coordinates to polar coordinates.</li> </ul>"},{"location":"topics/conventions/#help-lines","title":"Help Lines","text":"<p><code>canvas.help_lines()</code> method can be used to draw a grid with the origin (depicted with a circle), x (colored red), and y-axis (colored green) shown on the canvas. The <code>help_lines</code> method has the following signature:</p> <pre><code>canvas.help_lines(pos: Point=(-100, -100), width: float=600, height: float=600,\n                                                            spacing: float=25)\n</code></pre> <p></p>"},{"location":"topics/conventions/#coordinate-transformations","title":"Coordinate transformations","text":"<p><code>Canvas</code> object can be translated, rotated, and scaled. The order of transformations can be important. All drawing operations performed following the transformation will be affected by the transformation. Help-lines reflect the coordinate transformations as well.</p> Rotated <code>Canvas</code>Translated letter_F and Rotated Canvas Transformed Canvas<pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nF = sg.letter_F(fill_color=sg.teal, line_width=2, alpha=.5) # (1)!\ncanvas.draw(F, fill_color=sg.burgundy)\ncanvas.rotate(-sg.pi/4)\n\ncanvas.help_lines() # (2)!\ncanvas.draw(F)\n\ncanvas.save('/your/path/translate_rotate.png', overwrite=True)\n</code></pre> <ol> <li> <p><code>sg.letter_F()</code></p> <code>letter_F()</code> is a function that returns an F-shaped object. Since this shape has no symmetries, it is a good example to show the effect of transformations.</li> <li> <p>canvas.help_lines() after canvas.rotate()</p>     Since the help_lines are drawn after the rotation, they will be rotated as well.</li> </ol> <p></p> <p>Transformed letter_F and Canvas<pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nF = sg.letter_F(fill_color=sg.teal, line_width=2, alpha=.5)\nF.translate(100, 100)\n\ncanvas.draw(F, fill_color=sg.burgundy)\ncanvas.rotate(-sg.pi/4)\n\ncanvas.help_lines()\ncanvas.draw(F)\n\ncanvas.save('/your/path/rotate.png', overwrite=True)\n</code></pre> </p>"},{"location":"topics/conventions/#units","title":"Units","text":"<p>For defining geometry (using <code>Shape</code> objects), S\u0130METR\u0130 uses <code>points</code> as the unit of measurement. For images, the unit of measurement is <code>pixels</code>. The conversion between points and pixels is as follows (assuming a resolution of 96 DPI):</p> <ul> <li>1 point = 1 / 72 inch</li> <li>1 pixel = 1 / 96 inch (1 / DPI)</li> <li>1 point = 0.75 pixel (72 / DPI)</li> </ul> <p>All angles are in radians. The conversion between degrees and radians is as follows:</p> <ul> <li>1 degree = \\(\\frac{\\pi}{180}\\) radians</li> <li>1 radian = \\(\\frac{180}{\\pi}\\) degrees</li> <li>1 radian = 57.2958 degrees</li> </ul>"},{"location":"topics/conventions/#other-units-used-in-latex","title":"Other units used in \\(\\LaTeX\\)","text":"Unit Explanation pt Equal to 1/72.27 inch in inch mm millimeter cm centimeter ex height of an 'x' character in the current font em width of an 'M' character in the current font mu 1/18 em sp special point, 65,536sp = 1pt"},{"location":"topics/conventions/#points-vertices-and-coordinates","title":"Points, vertices, and coordinates","text":"<p>In S\u0130METR\u0130, points are represented as sequences of two or three values. The first two values correspond to the x and y coordinates of the point, while the third value, which is always 1, represents the point in homogeneous coordinates. Internally, multiple points are stored as NumPy arrays, specifically as a 2D array with the shape (n, 3), where n is the number of points. For 2D points, the third value remains 1 to ensure representation in homogeneous coordinates.</p> <p>The term \"points\" usually refers to the initial (x, y) coordinates, while \"vertices\" refer to the <code>shape.vertices</code> property, which is a tuple of (x, y) tuples. Since tuples are immutable in Python, the vertices cannot be modified directly. However, <code>Shape</code> objects can behave like Python lists, allowing for the modification, addition and removal of points. The term \"coordinates\" can refer to either the initial points or the vertices, depending on the context.</p>"},{"location":"topics/conventions/#matrices","title":"Matrices","text":"<p>Matrices serve as the backbone of the S\u0130METR\u0130 library. They are utilized for defining geometry (as \ud835\udc5b \u00d7 3 matrices representing \ud835\udc5b points) and performing transformations (as 3 \u00d7 3 matrices). The transformation matrix, specifically a 3 \u00d7 3 matrix, is used to transform points in homogeneous coordinates. Both geometry definition and transformations follow column-major order to avoid the need for transposing matrices back and forth. Although most modern linear-algebra books use row-major order, as long as we are consistent this difference does not pose any issues. The transformation matrix can be summarized as follows:</p> \\[T = \\begin{bmatrix} \\cos \\theta &amp; \\sin \\theta &amp; s_x\\\\ -\\sin \\theta &amp; \\cos \\theta &amp; s_y\\\\ d_x &amp; d_y &amp; 1 \\end{bmatrix}\\] <p>where \\(\\theta\\) is the angle of rotation in radians, \\(s_x\\) and \\(s_y\\) are the scaling factors in the x and y directions, respectively, and \\(d_x\\) and \\(d_y\\) are the translation factors in the x and y directions, respectively.</p> How to read composite transformations. <p>When we combine multiple transformations, the order of operations matters. For example, if we want to apply a translation followed by a rotation, we need to multiply the translation matrix by the rotation matrix. The order of multiplication is important because matrix multiplication is not commutative. In other words, \\(T_1 \\cdot T_2 \\neq T_2 \\cdot T_1\\).</p> <p>If the matrices are in row-major order, the multiplication order is from right to left. This convention is popular because it is consistent with the way functions are applied in mathematics.</p> <p>In S\u0130METR\u0130, we use column-major order for matrices, which means that the multiplication order is from left to right. This is easier to read for beginners but it may cause problems for people who are used to the row-major order.</p> <p>Every <code>Shape</code> object is initiated with the identity matrix. The identity matrix is a square matrix with ones on the diagonal and zeros elsewhere. It is represented as follows:</p> \\[I = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] <p>Every transformation is represented as a matrix multiplication. For example, the transformation of a point \\(P\\) is represented as:</p> \\[P' = P \\cdot T\\] <p>where \\(P'\\) is the transformed point, \\(T\\) is the transformation matrix, and \\(P\\) is the original point.</p> <p>When we have n points, the transformation is represented as:</p> \\[P = \\begin{bmatrix} x_1 &amp; y_1 &amp; 1\\\\ x_2 &amp; y_2 &amp; 1\\\\ \\vdots &amp; \\vdots &amp; \\vdots\\\\ x_n &amp; y_n &amp; 1\\\\ \\end{bmatrix}\\] \\[P' = P \\cdot T\\] \\[P' = \\begin{bmatrix} x'_1 &amp; y'_1 &amp; 1\\\\ x'_2 &amp; y'_2 &amp; 1\\\\ \\vdots &amp; \\vdots &amp; \\vdots\\\\ x'_n &amp; y'_n &amp; 1\\\\ \\end{bmatrix}\\] <p>where \\(P'\\) is the transformed points, \\(T\\) is the transformation matrix, and \\(P\\) is the original points.</p> <p>The key advantage of these matrix representations is their efficiency in computing multiple transformations across multiple points simultaneously. Instead of applying each transformation to individual points one by one, we can first multiply the transformation matrices together and then apply the resulting matrix to all points in a single operation. This approach significantly improves computational speed, especially when dealing with large numbers of points.</p> <p>Matrix multiplication is not commutative:  \\(T_1 \\cdot T_2 \\neq T_2 \\cdot T_1\\)</p>"},{"location":"topics/conventions/#chaining-methods","title":"Chaining methods","text":"<p>Most methods in S\u0130METR\u0130 return the object itself. This allows for chaining methods together to create more complex transformations. For example, the following code applies successive transformations to a shape:</p> <pre><code>shape.translate(10, 20).rotate(30).scale(2, 3)\n</code></pre> <p>Most <code>Canvas</code> methods also return the object itself (<code>Canvas</code> object), allowing for chaining methods together. For example, the following code applies successive <code>Canvas</code> operations in a single line:</p> <pre><code>canvas.draw(shape).translate(100, 0).draw(shape2).save('output.png')\n</code></pre>"},{"location":"topics/conventions/#arguments-with-none-default-values","title":"Arguments with <code>None</code> default values","text":"<p>Allmost all methods in S\u0130METR\u0130 have default values for their arguments. If an argument is not specified, the default value will be used.</p>"},{"location":"topics/extensions/","title":"Extensions","text":""},{"location":"topics/extensions/#extensions","title":"Extensions","text":"<ul> <li>Interlaced patterns</li> <li>Wallpaper-groups</li> <li>Frieze-groups</li> <li>Stars</li> <li>Turtle-graphics</li> <li>L-Systems</li> <li>Tree maker</li> </ul>"},{"location":"topics/images/","title":"Images","text":"","tags":["images"]},{"location":"topics/images/#images","title":"Images","text":"","tags":["images"]},{"location":"topics/images/#working-with-images","title":"Working with images","text":"","tags":["images"]},{"location":"topics/images/#pil-image-object","title":"PIL Image Object","text":"<p>The Image object in S\u0130METR\u0130 inherits from the PIL (Pillow) library and adds more methods to blend it with the rest of the S\u0130METR\u0130 library. There are some fundamental differences between the PIL's Image object and S\u0130METR\u0130' Image object.</p> <p>Image objects are still experimental and subject to change!</p> <p>In addition to the possibility of inserting images into \\(\\TeX\\) code, we can use images to generate output without having to compile a \\(\\TeX\\) file. One of the major issues with compiling \\(\\TeX\\) files is the memory size limitations that a \\(\\TeX\\) compiler (XeLaTeX in S\u0130METR\u0130) has. We can generate an image directly (without compiling) by using the <code>draw</code> method of the <code>Canvas.save</code> method with the <code>img</code> argument. Not every option (shadings, grids, line-styles, etc.) is compatible with this method.</p> <p>For PDF images, S\u0130METR\u0130 uses the <code>PyMuPDf</code> library. You can see their documentation for further info.</p> <p>You can use the comprehensive documentation at the Pillow website for more information. S\u0130METR\u0130's API documentation doesn't include the whole PIL library, just the Image module.</p> PIL uses a flipped y-axis and the origin is located at the upper-left corner! <p>The origin of PIL Image objects is located at the upper right corner.  To align with the rest of the S\u0130METR\u0130 library, the origin of sg.Image objects is positioned at the lower left corner, with the positive y direction pointing upwards.</p> <p>Image objects can be initiated by using an existing image file as shown below.</p> <pre><code>&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; img = sg.Image(img=\"/your/path/here.png\") # (1)!\n&gt;&gt;&gt; print(img.info) # (2)!\n    {'dpi': (96.012, 96.012)}\n&gt;&gt;&gt; img.show() # (3)!\n&gt;&gt;&gt; img.size\n    (374, 331)\n&gt;&gt;&gt; img.format\n    'PNG'\n&gt;&gt;&gt; img.mode\n    'RGB'\n&gt;&gt;&gt; img.filename # (4)!\n    'your\\path\\here.png'\n&gt;&gt;&gt; thumb_size = (64, 64)\n&gt;&gt;&gt; img.thumbnail(thumb_size)\n&gt;&gt;&gt; img.save(\"/your/path/here_tn.png\")\n&gt;&gt;&gt; img.size\n    (64, 57) # (5)!\n&gt;&gt;&gt; img2 = sg.Image.open(\"/your/path/here.png\")\n&gt;&gt;&gt; img2.crop((left=10, bottom=10, right=320, top=320)) # (6)!\n    &lt;PIL.Image.Image image mode=RGB size=310x310 at 0x28FB7F90050&gt;\n&gt;&gt;&gt; cropped = img2.crop((10, 10, 320, 320)) # (6)!\n&gt;&gt;&gt; cropped.thumbnail(thumb_size)\n&gt;&gt;&gt; cropped.size\n&gt;&gt;&gt; (64, 64)\n&gt;&gt;&gt;\n</code></pre> <ol> <li> If the image file resides in the same directory as the script file then the full-path is not necessary, just the filename would be sufficient. </li> <li> The <code>info</code> property returns a dictionary with the image's metadata. Some images have no data in the <code>info</code> property. </li> <li> This uses the system's preview setting. This could be different for each image format. </li> <li> The <code>filename</code> property applies only to images created from an existing image file. </li> <li> Since the original picture was not square, we got a proportionally sized thumbnail.\" </li> <li> Unlike the <code>thumbnail</code> method, <code>crop</code> method does not modify the original image, it returns a new image with the given size. </li> <li> Since the coordinate-systems are different, this operation yields a different result than cropping the same image with PIL's Image object. While PIL uses <code>crop(left, top, right, bottom)</code>, S\u0130METR\u0130 uses <code>crop(left, bottom, right, top)</code>. </li> </ol> <p>Images can be created from scratch or opened from existing files.</p>","tags":["images"]},{"location":"topics/images/#supported-image-formats","title":"Supported image formats","text":"<p>PIL's Image module can handle numerous different formats in different ways. These formats may not be available in all environments depending on the OS.</p> <ul> <li>Fully supported formats: AVIF, BLP, BMP, DDS, DIB, EPS, GIF, ICNS, ICO, IM, JPEG, JPEG 2000, MPO, MSP, PCX, PFM, PNG, APNG, SPIDER, TGA, TIFF, WebP, and XBM.</li> <li>Read-only formats: CUR, DCX, FITS, FLI, FLC, FPX, FTEX, GBR, GD, IMT, IPTC/NAA, MCIDAS, MIC, PCD, PIXAR, PSD, QOI, SUN, WAL, WMF/EMF, and XPM.</li> <li>Write-only formats: PDF, XV Thumbnails.</li> <li>Identify-only formats: BUFR, GRIB, HDF5, and MPEG.</li> </ul>","tags":["images"]},{"location":"topics/images/#creating-a-new-image","title":"Creating a new image","text":"<p>To create a new image, we can use the <code>sg.Image(pos, size, mode)</code> method.</p> <p><code>PIL.Image.new(mode: str, size: tuple[int, int] | list[int], color: float | tuple[float, ...] | str | None = 0) \u2192 Image[source]</code></p> <p>Creates a new image with the given mode and size.</p> <p>Parameters:</p> <ul> <li><code>mode</code> : The mode to use for the new image. See: Modes.</li> <li><code>size</code> : A 2-tuple, containing (width, height) in pixels.</li> <li><code>color</code> : What color to use for the image. Default is black. If given, this should be a single integer or floating point value for single-band modes, and a tuple for multi-band modes (one value per band). When creating RGB or HSV images, you can also use <code>sg.Color</code> objects or named-colors.  If the color is None, the image is not initialized.</li> </ul> <p>Returns: An Image object.</p> <p></p>","tags":["images"]},{"location":"topics/images/#modes","title":"Modes","text":"<p>This section is taken from: https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes</p> <p>The <code>mode</code> of an image is a string which defines the type and depth of a pixel in the image. Each pixel uses the full range of the bit depth. So a 1-bit pixel has a range of 0-1, an 8-bit pixel has a range of 0-255, a 32-signed integer pixel has the range of INT32 and a 32-bit floating point pixel has the range of FLOAT32. The current release supports the following standard modes:</p> <pre><code>* ``1`` (1-bit pixels, black and white, stored with one pixel per byte)\n* ``L`` (8-bit pixels, grayscale)\n* ``P`` (8-bit pixels, mapped to any other mode using a color palette)\n* ``RGB`` (3x8-bit pixels, true color)\n* ``RGBA`` (4x8-bit pixels, true color with transparency mask)\n* ``CMYK`` (4x8-bit pixels, color separation)\n* ``YCbCr`` (3x8-bit pixels, color video format)\n\n  * Note that this refers to the JPEG, and not the ITU-R BT.2020, standard\n\n* ``LAB`` (3x8-bit pixels, the L*a*b color space)\n* ``HSV`` (3x8-bit pixels, Hue, Saturation, Value color space)\n\n  * Hue's range of 0-255 is a scaled version of 0 degrees &lt;= Hue &lt; 360 degrees\n\n* ``I`` (32-bit signed integer pixels)\n* ``F`` (32-bit floating point pixels)\n</code></pre> <p>Pillow also provides limited support for a few additional modes, including:</p> <pre><code>* ``LA`` (L with alpha)\n* ``PA`` (P with alpha)\n* ``RGBX`` (true color with padding)\n* ``RGBa`` (true color with premultiplied alpha)\n* ``La`` (L with premultiplied alpha)\n* ``I;16`` (16-bit unsigned integer pixels)\n* ``I;16L`` (16-bit little endian unsigned integer pixels)\n* ``I;16B`` (16-bit big endian unsigned integer pixels)\n* ``I;16N`` (16-bit native endian unsigned integer pixels)\n</code></pre> <p>Premultiplied alpha is where the values for each other channel have been multiplied by the alpha. For example, an RGBA pixel of <code>(10, 20, 30, 127)</code> would convert to an RGBa pixel of <code>(5, 10, 15, 127)</code>. The values of the R, G and B channels are halved as a result of the half transparency in the alpha channel.</p> <p>Apart from these additional modes, Pillow doesn't yet support multichannel images with a depth of more than 8 bits per channel.</p> <p>Pillow also doesn\u2019t support user-defined modes; if you need to handle band combinations that are not listed above, use a sequence of Image objects.</p> <p>You can read the mode of an image through the <code>PIL.Image.Image.mode</code> attribute. This is a string containing one of the above values.</p> <p></p>","tags":["images"]},{"location":"topics/images/#transformations","title":"Transformations","text":"<p><code>Image</code> objects can be transformed like the <code>Shape</code> and <code>Batch</code> objects. If you are not familiar with transformations in S\u0130METR\u0130, please see transformations. Some examples of transformations applied to <code>Image</code> objects are shown below.</p> <p><pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\nstar = sg.stars.Star(n=12, circumradius=150).level(4)\nlace = sg.Lace(star, swatch=sg.random_swatch(), offset=5)\ncanvas.draw(lace.scale(.25))\ncanvas.border = 0\nfile_path = '/your/path/star_pic.ps'\ncanvas.save(file_path, overwrite=True, show=False)\nimg = sg.Image(file_path)\ndx, dy = img.size\nimages = img.translate(dx, 0, reps=3).translate(0, dy, reps=3)\ncanvas.reset()\ncanvas.draw(images)\ncanvas.save('/your/path/star_pic_translated.svg', overwrite=True)\n</code></pre> </p>","tags":["images"]},{"location":"topics/images/#categories","title":"Categories","text":"<ul> <li>Elements</li> </ul>","tags":["images"]},{"location":"topics/implementation/","title":"Implementation","text":""},{"location":"topics/implementation/#implementation","title":"Implementation","text":"<p>To use S\u0130METR\u0130 at an advanced level, we may need to understand some of its implementation details. We will summarize some details in a few separate documents listed below.</p> <p>You can always see the code in the API page or our GitHub page.</p>"},{"location":"topics/implementation/#rendering-pipeline","title":"Rendering pipeline","text":""},{"location":"topics/implementation/#shape-objects","title":"<code>Shape</code> objects","text":""},{"location":"topics/implementation/#batch-objects","title":"<code>Batch</code> objects","text":""},{"location":"topics/implementation/#style-properties","title":"Style properties","text":""},{"location":"topics/implementation/#pattern-objects","title":"<code>Pattern</code> objects","text":""},{"location":"topics/implementation/#placements-using-references","title":"Placements using references","text":""},{"location":"topics/linpath_doc/","title":"Paths","text":""},{"location":"topics/linpath_doc/#linpath-path-objects","title":"<code>LinPath</code> Path Objects","text":""},{"location":"topics/linpath_doc/#linpath","title":"LinPath","text":"<p><code>LinPath</code> objects are used for creating paths formed by straight and curved lines.</p> <p>They have <code>pos</code> and <code>angle</code> properties that define the current position and orientation angle respectively. Their default position is the origin and their default angle is 90 degrees (facing upward).</p> <p>Their initial position and angle can be specified in the constructor.</p> <pre><code>import simetri.graphics as sg\n\npi = sg.pi\npath = sg.LinPath()\nprint(f\"path.pos: {path.pos}\")\nprint(f\"path.angle: {sg.degrees(path.angle)} degrees\\n\")\n\npath2 = sg.LinPath((50, 70))\npath2.angle = pi/3\nprint(f\"path2.pos: {path.pos}\")\nprint(f\"path2.angle: {sg.degrees(path.angle)} degrees\")\n</code></pre> <pre><code>path.pos: (0, 0)\npath.angle: 90.0 degrees\n\npath2.pos: (0, 0)\npath2.angle: 90.0 degrees\n</code></pre> path.forward(dist) <code>path.forward</code> draws a line in the same orientation as the <code>path.angle</code> with given length. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=300, height=300, spacing=50)\n\npath = sg.LinPath()\npath.angle = pi/4\npath.forward(70.71)\npath.angle = 0\npath.forward(100)\npath.angle = pi/2\npath.forward(100)\n\ncanvas.draw(path, line_width=2)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\n\npath = sg.LinPath()\npath.angle = sg.pi\nd = 120\nfor i in range(12):\n    path.forward(d)\n    d -= 10\n    path.angle -= sg.pi/2\n\npaths = path.translate(120, 0, reps=4)\ncanvas.draw(paths, line_width=10, line_color=sg.terra_cotta)\ncanvas.help_lines(pos=(-150, -50), width=700, height=200, spacing=25)\ncanvas.display()\n</code></pre> <p></p> path.line_to(point) Draws a line between the path's current position and the given point. Path object's orientation angle changes to the orientation angle of the specified line, and its position changes to the given point. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=200, height=150, spacing=50)\n\npath = sg.LinPath()\npath.line_to((120, 60))\nprint(f\"path.pos: {path.pos}\")\nprint(f\"path.angle: {sg.degrees(path.angle):.2f} degrees\")\n\ncanvas.draw(path, line_width=2)\n\ncanvas.display()\n</code></pre> <pre><code>path.pos: (120, 60)\npath.angle: 26.57 degrees\n</code></pre> <p></p> path.h_line(dist) <code>path.h_line</code> draws a horizontal line with the given distance. If the <code>dist</code> argument is negative then line is drawn in <code>-x</code> direction. path.v_line(dist) <code>path.v_line</code> draws a vertical line with the given distance. If the <code>dist</code> argument is negative then line is drawn in <code>-y</code> direction. path.close() <code>path.close()</code> closes the path. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=300, height=150, spacing=50)\n\npath = sg.LinPath((50, 0))\npath.h_line(150)\npath.v_line(50)\npath.h_line(-100)\npath.v_line(-30)\npath.close()\n\ncanvas.draw(path, line_width=2)\n\ncanvas.display()\n</code></pre> <p></p> path.arc(radius_x, radius_y, start_angle, span_angle, rot_angle) <code>path.arc</code> draws and elliptic arc with the given parameters. Angles are in radians and counterclockwise positive from the positive x-axis. <pre><code>import simetri.graphics as sg\npi = sg.pi\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -100), width=800, height=250, spacing=25)\npath = sg.LinPath()\n\npath.arc(80, 40, pi, -pi/2)\ncanvas.draw(path, line_width=2, line_color=sg.blue)\n\npath2 = sg.LinPath((100, 0))\npath2.arc(80, 40, -pi/2, pi/2)\ncanvas.draw(path2, line_width=2, line_color=sg.red)\n\npath3 = sg.LinPath((200, 0))\npath3.arc(80, 40, pi/2, -pi/2)\ncanvas.draw(path3, line_width=2, line_color=sg.green)\n\npath4 = sg.LinPath((300, 0))\npath4.arc(80, 40, pi, pi/2)\ncanvas.draw(path4, line_width=2, line_color=sg.orange)\n\npath5 = sg.LinPath((400, 0))\npath5.arc(50, 50, pi, 3 * pi/2)\npath5.close()\ncanvas.draw(path5, line_width=2, fill_color=sg.purple)\n\npath6 = sg.LinPath((550, 0))\npath6.arc(25, 25, pi, -pi/2)\npath6.arc(25, 25, -pi/2, pi/2)\npath6.arc(50, 50, pi, -3 * pi/2)\npath6.arc(25, 25, pi/2, pi/2)\npath6.arc(37.5, 37.5, 0, -pi)\n\ncanvas.draw(path6, line_width=2)\n\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ndef curly_brace(pos, angle, length=100, radius=10):\n    x, y = pos[:2]\n    x1 = length /2\n    y1 = 2 * radius\n    half = sg.LinPath()\n    half.arc(radius_x=radius, radius_y=radius, start_angle=sg.pi, span_angle=-sg.pi/2)\n    half.forward(x1 - y1)\n    half.arc(radius_x=radius, radius_y=radius, start_angle=3*sg.pi/2, span_angle=sg.pi/2)\n    brace = half.mirror(half.right, reps=1)\n\n    brace.rotate(angle, (x1, y1))\n    x2 = x - (length / 2)\n    y2 = y - (2*radius)\n    brace.translate(x2, y2)\n\n    return brace\n\ncanvas.help_lines(pos=(-50, -50), width=300, height=200, spacing=25)\nbrace = curly_brace((50, 50), sg.pi/4, length=150)\nbrace2 = curly_brace((200, 50), -sg.pi/6, length=100)\n\ncanvas.draw([brace, brace2], line_width=2)\ncanvas.display()\n</code></pre> <p></p> path.cubic_to(control1, control2, end) <code>path.cubic_to</code> draws a cubic Bezier curve using the path's position, given control points, and the end point. Path objects can be transformed like any other Shape object. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -100), width=900, height=250, spacing=25)\n\npath = sg.LinPath()\npath.cubic_to((100, 100), (100, -50), (200, 0))\ncanvas.draw(path, line_width=2, handles=True)\n\npath2 = sg.LinPath((250, 0))\npath2.cubic_to((275, 100), (400, 75), (500, 0))\ncanvas.draw(path2, line_width=2, handles=True, line_color=sg.red)\n\npath3 = sg.LinPath((550, 0))\npath3.cubic_to((575, 100), (700, 75), (800, 0))\ncanvas.draw(path3, line_width=2, line_color=sg.blue)\n\nshape = path3.mirror(sg.axis_x, reps=1).scale(.5, about=path3.center)\nshape.translate(0, 75, reps=1)\ncanvas.draw(shape, line_width=2, line_color=sg.green)\n\n\ncanvas.display()\n</code></pre> <p></p> path.quad_to(control, end) <code>path.quad_to</code> draws a quadratic Bezier curve using the path's position, given control point, and the end point. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -150), width=650, height=300, spacing=25)\n\npath = sg.LinPath()\npath.quad_to((100, 100), (300, 0))\ncanvas.draw(path, line_width=2, handles=True)\n\npath = sg.LinPath((325, 0))\npath.quad_to((525, -75), (500, 0))\ncanvas.draw(path, line_width=2, handles=True)\n\n\ncanvas.display()\n</code></pre> <p></p> path.hobby_to(points) Draws a Hobby curve through the given points. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -150), width=500, height=300, spacing=25)\n\npath = sg.LinPath()\n\npoints = [(0, 0), (200, 100), (300, 50), (400, -50), (300, -100),\n                (200, 0), (100, 50), (10, 0)]\npath.hobby_to(points)\nfor p in points:\n    canvas.circle(p, 3)\n\ncanvas.draw(path, line_width=2, handles=True)\ncanvas.display()\n</code></pre> <p></p> path.sine_to(period, amplitude, duration, phase_angle, damping) <code>path.sine_to</code> draws a sine-wave using the given arguments. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -100), width=800, height=200, spacing=25)\n\npath = sg.LinPath()\npath.sine(period=50, amplitude=25, duration=150)\ncanvas.draw(path, line_width=2, line_color=sg.blue)\n\npath2 = sg.LinPath((200, 0))\npath2.sine(period=50, amplitude=25, duration=125, phase_angle=sg.pi/2)\ncanvas.draw(path2, line_width=2, line_color=sg.red)\n\npath3 = sg.LinPath((350, 0))\npath3.sine(period=20, amplitude=90, duration=350, damping=.005)\ncanvas.draw(path3, line_width=1.5)\n\ncanvas.display()\n</code></pre> <p></p> path.move_to(point) <code>path.move_to</code> changes the path's position without drawing a line. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=450, height=200, spacing=25)\n\npath = sg.LinPath()\nfor i in range(5):\n    path.h_line(75)\n    c = (i + 1)\n    path.move_to((c*75, c*25))\n\n\ncanvas.draw(path, line_width=2)\ncanvas.display()\n</code></pre> <p></p> path.turn(angle, distance) <code>path.turn</code> turns the path by the given angle (in radians) and moves it forward by the given distance. The angle is in radians and counterclockwise positive from the positive x-axis. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=300, height=200, spacing=25)\n\npath = sg.LinPath()\npath.forward(50)\npath.turn(-sg.pi/4, 100)\npath.turn(-sg.pi/2, 100)\ncanvas.draw(path, line_width=2)\ncanvas.display()\n</code></pre> <p></p>"},{"location":"topics/linpath_doc/#relative-motions","title":"Relative motions","text":"<p>For some path operations, we can specify the coordinates relative to the current path position.</p> <p>New position is computed by adding dx to the path's x coordinate and dy to the path's y coordinate. Path's angle is ignored.</p> path.r_line(dx, dy) <code>path.r_line</code> draws a line between the path's position and (dx, dy) offset from this position. path.r_move(dx, dy) <code>path.r_move</code> moves the path by the given offset values without drawing a line. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=450, height=150, spacing=25)\n\npath = sg.LinPath()\nfor i in range(7):\n    x = 40 - i * 5\n    y = 40 - i * 5\n    path.r_line(x, y)\n    path.r_line(x, -y)\n\npath.r_move(0, 50)\n\nfor i in range(7):\n    x = 40 - i * 5\n    y = 40 - i * 5\n    path.r_line(-x, y)\n    path.r_line(-x, -y)\n\n\ncanvas.draw(path, line_width=2)\ncanvas.display()\n</code></pre> <p></p>"},{"location":"topics/linpath_doc/#blended-operations","title":"Blended operations.","text":"<p>These operations blend the drawn lines to the path by using paths orientation angle.</p> path.blend_arc(radius_x, radius_y, start_angle, span_angle, sharp=False) Blends an arc to the path. If the <code>sharp</code> argument is True then blending is reversed by 180 degree. <pre><code>import simetri.graphics as sg\n\npi = sg.pi\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -50), width=500, height=175, spacing=25)\n\npath = sg.LinPath()\npath.angle = pi/4\n\npath.forward(50)\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_arc(radius_x=50, radius_y=25, start_angle=pi/2, span_angle=-2*pi/3)\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_arc(radius_x=50, radius_y=25, start_angle=pi/2, span_angle=pi)\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_arc(radius_x=80, radius_y=50, start_angle=0, span_angle=-5*pi/6)\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_arc(radius_x=30, radius_y=30, start_angle=0, span_angle=-pi, sharp=True)\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_arc(radius_x=60, radius_y=30, start_angle=0, span_angle=-pi, sharp=True)\n\ncanvas.draw(path, line_width=2)\ncanvas.display()\n</code></pre> <p></p> path.blend_cubic(control1_length, control2, end) Blends a cubic Bezier curve to the path. path.blend_quad(control_length, end) Blends a quadratic Bezier curve to the path. <pre><code>import simetri.graphics as sg\n\npi = sg.pi\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -150), width=600, height=350, spacing=50)\n\npath = sg.LinPath()\npath.angle = pi/4\n\npath.forward(100)\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_cubic(150, (170, 80), (200, 0))\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_cubic(100, (230, -50), (300, 0))\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\n\npath.blend_quad(150, (400, 20))\ncanvas.circle(path.pos, 3, fill_color=sg.red, stroke=False)\npath.blend_quad(50, (500, 0))\n\ncanvas.draw(path, line_width=2)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\npath = sg.LinPath()\npath.cubic_to(control1=(20, 140), control2=(180, -40), end=(280, 60))\npath.blend_cubic(control1_length=150, control2=(490, 100), end=(500, 0))\n\ncanvas.draw(path, handles=True)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\npath = sg.LinPath((0, -40))\npath.forward(40)\npath.cubic_to(control1=(40, 160), control2=(140, 30), end=(180, 60))\npath.blend_arc(radius_x=50, radius_y=20, start_angle=sg.radians(170), span_angle=sg.radians(200), sharp=True)\npath.blend_cubic(control1_length=-70, control2=(470, 230), end=(540, 0))\npath.v_line(-40)\n\npaths = path.mirror(path.bottom, reps=1)\n\ncanvas.draw(paths, line_width=2, line_join=sg.LineJoin.BEVEL)\n\nstrings = sg.Shape([(0, -17.5), (500, -17.5)]).translate(0, -15, reps=3)\ncanvas.draw(strings, line_width=2)\ncanvas.line((500, -17.5), (500, -62.5), line_width=6)\ncanvas.display()\n</code></pre> <p></p> path.blend_sine(period, amplitude, duration, phase_angle, damping) Blends a sine wave to the path. <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ncanvas.help_lines(pos=(-50, -75), width=600, height=225, spacing=25)\n\npath = sg.LinPath()\npath.line_to((100, 100))\npath.blend_sine(period=50, amplitude=25, duration=150)\npath.blend_arc(radius_x=50, radius_y=50, start_angle=0, span_angle=-pi/2)\npath.blend_arc(radius_x=100, radius_y=50, start_angle=0, span_angle=pi/2)\npath.blend_sine(period=50, amplitude=25, duration=150)\n\ncanvas.draw(path, line_width=2, line_color=sg.blue)\ncanvas.display()\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\npath = sg.LinPath()\npath.forward(30)\n\npath.blend_sine(amplitude=10, duration=200, damping=.01)\npath.close()\n\npaths = path.mirror([(0, 0), path.vertices[-2]], reps=1)\npaths.mirror(paths.right, reps=1)\npaths.mirror(paths.top, reps=1)\n\ncanvas.draw(paths)\n\ncanvas.display()\n</code></pre> <p></p>"},{"location":"topics/linpath_doc/#path-utility-functions","title":"Path utility functions","text":"<p>Path objects provides a number of utility functions to help with drawing and manipulating paths. These include: <code>path.push</code>, <code>path.pop</code>, <code>path.r_coord</code>, and <code>path.r_polar</code>.</p> <ul> <li><code>path.r_coord(dx, dy)</code>: Returns a position by offsetting the path's current position by <code>dx</code> and <code>dy</code> along the aligned axes to the path's angle (visualize a coordinate system with the origin at the path's position and the positive y-axis is aligned with the path's angle.</li> <li><code>path.r_polar(r, theta)</code>: Returns a position by offsetting path's current position by <code>r * cos(theta)</code> and <code>r * sin(theta)</code> from the polar coordinate system with the origin at the path's position and the zero degree line oriented 90 degrees clockwise from the path's orientation angle.</li> </ul> <p>Unlike the <code>path.r_line</code> and <code>path.r_move</code> operations, <code>path.r_coord</code> and <code>path.r_polar</code> is computed by using the <code>path.angle</code>.</p> <p>Path objects have a LIFO stack (last in first out) that holds (position, angle) tuples.</p> path.push Pushes the path's position and angle to path's stack. path.pop Pops the position and angle values from the stack and applies them to the path object. Note:  Unlike the `path.r_line` and `path.r_move` operations, `path.r_coord` and `path.r_polar` is computed by using the `path.angle`.  <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\ncanvas.help_lines(pos=(-50, -50), width=200, height=200, spacing=25)\n\npath = sg.LinPath()\nprint(f\"path.pos: {path.pos}\")\npath.line_to((50, 50))\nprint(f\"path.r_coord(20, -30): {path.r_coord(50, 50)}\")\ncanvas.circle(path.r_coord(50, 50), 3, fill_color=sg.red, stroke=False)\n\npath2 = sg.LinPath(path.pos)\npath2.angle = path.angle\npath2.push()\n\npath2.forward(50)\npath2.pop()\npath2.angle -= pi/2\npath2.forward(50)\n\ncanvas.draw(path)\ncanvas.draw(path2, line_width=2, line_color=sg.blue)\n\ncanvas.display()\n</code></pre> <pre><code>path.pos: (0, 0)\npath.r_coord(20, -30): (120.71067811865476, 50.0)\n</code></pre> <p></p> <pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\nfor i in range(4):\n    path = sg.LinPath()\n    path.angle = sg.radians(i * 90)\n    path.forward(20)\n    x, y = path.r_coord(50, 50) # y-axis is aligned with the path.angle\n    canvas.circle((x, y), 3)\n    print(f\"path{i+1}.pos at first segment: {sg.round_point(path.pos)}\")\n    print(f\"path{i+1}.angle: {sg.degrees(path.angle):.1f} degrees\")\n    print(\"x, y = path.r_coord(50, 50)\")\n    print(f\"x: {x:.1f}, y: {y:.1f}\")\n    print('_' * 45)\n    path.line_to((x, y))\n    canvas.draw(path, line_width=2)\n    canvas.text(f\"path{i+1}\", (0, -60), font_size=16)\n    canvas.translate(150, 0)\n\ncanvas.display()\n</code></pre> <pre><code>path1.pos at first segment: (20.0, 0.0)\npath1.angle: 0.0 degrees\nx, y = path.r_coord(50, 50)\nx: 70.0, y: -50.0\n_____________________________________________\npath2.pos at first segment: (0.0, 20.0)\npath2.angle: 90.0 degrees\nx, y = path.r_coord(50, 50)\nx: 50.0, y: 70.0\n_____________________________________________\npath3.pos at first segment: (-20.0, 0.0)\npath3.angle: 180.0 degrees\nx, y = path.r_coord(50, 50)\nx: -70.0, y: 50.0\n_____________________________________________\npath4.pos at first segment: (-0.0, -20.0)\npath4.angle: -90.0 degrees\nx, y = path.r_coord(50, 50)\nx: -50.0, y: -70.0\n_____________________________________________\n</code></pre> <p></p> <pre><code>from math import copysign\n\nimport simetri.graphics as sg\n\ndef flower(radius, canvas, path):\n    canvas.circle(path.pos, 6, fill_color=sg.green)\n    angle = sg.pi/6\n    for i in range(9):\n        x, y = path.r_polar(radius, (i*angle) - angle)[:2]\n        canvas.circle((x, y), 2+i*.3, fill_color=sg.red)\n\ncanvas = sg.Canvas()\ndim = 15\npath = sg.LinPath()\npath.forward(5 * dim)\npath.push()\npath.r_line(4 * dim, 4 * dim)\nflower(dim, canvas, path)\ndist = 3 * dim\nfor i in range(10):\n    path.pop()\n    sign = copysign(1, i%2 - 0.5) # -1 if i%2 else 1\n    path.r_line(dim * sign , 2 * dim)\n    path.push()\n    delta = 4 * i\n    path.r_line(sign * (dist - delta), dist - delta)\n    flower(dim, canvas, path)\n\ncanvas.draw(path, line_width=3)\ncanvas.display()\n</code></pre> <p></p>"},{"location":"topics/modifiers/","title":"Modifiers","text":""},{"location":"topics/modifiers/#modifiers","title":"Modifiers","text":""},{"location":"topics/paths/","title":"Paths","text":""},{"location":"topics/paths/#paths","title":"Paths","text":""},{"location":"topics/patterns/","title":"Patterns","text":""},{"location":"topics/patterns/#patterns","title":"Patterns","text":"<p>Patterns are a mix of <code>Shape</code> and <code>Batch</code> objects. They are used to create large patterns with the same repeating shape. They have only one kernel (starting shape), a single style and a single composite transformation matrix. Unlike the regular transformation matrices this composite matrix has a size of (3 \u00d7 3\ud835\udc5b) where \ud835\udc5b is the number of distinct transformations. For example, if we mirror a shape with one repetition followed by a translation with three repetitions followed by another translation with four repetitions, the size of the composite transformation matrix would be:</p> \\[n = (1 + 1)\\cdot (3 + 1)\\cdot (4 + 1)\\cdot 3 = 120\\] <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import simetri.graphics as sg\n&gt;&gt;&gt; reps1, reps2, reps3 = 1, 3, 4\n&gt;&gt;&gt; hex = sg.reg_poly_shape(pos=(0, 0), n=6, r=40)\n&gt;&gt;&gt; hexes = sg.Pattern(hex)\n&gt;&gt;&gt; hexes.mirror(about=(hex[0], hex[1]), reps=reps1)\n&gt;&gt;&gt; hexes.translate(132, 0, reps=reps2)\n&gt;&gt;&gt; hexes.translate(-4, 85, reps=reps3)\n&gt;&gt;&gt; hexes.composite.shape\n    (3, 120)\n&gt;&gt;&gt; (reps1 + 1) * (reps2 + 1) * (reps3 + 1) * 3\n    120\n&gt;&gt;&gt; hexes.count # number of shapes in the pattern\n    40\n&gt;&gt;&gt; vertices = hex.final_coords @ hexes.composite\n&gt;&gt;&gt; vertices.shape\n    (6, 120)\n&gt;&gt;&gt; transformed = np.hsplit(vertices, hexes.count))\n&gt;&gt;&gt; transformed[0].shape\n    (6, 3)\n&gt;&gt;&gt; transformed[0]\n    array([[ 4.00000000e+01,  0.00000000e+00,  1.00000000e+00],\n           [ 2.00000000e+01,  3.46410162e+01,  1.00000000e+00],\n           [-2.00000000e+01,  3.46410162e+01,  1.00000000e+00],\n           [-4.00000000e+01,  4.89858720e-15,  1.00000000e+00],\n           [-2.00000000e+01, -3.46410162e+01,  1.00000000e+00],\n           [ 2.00000000e+01, -3.46410162e+01,  1.00000000e+00]])\n&gt;&gt;&gt; canvas = sg.Canvas()\n&gt;&gt;&gt; canvas.draw(hexes, line_width=2, fill_color=sg.algae, fillet_radius=5,\n            draw_fillets=True)\n&gt;&gt;&gt; canvas.save('/your/path/pattern_hex.svg', overwrite=True)\n&gt;&gt;&gt;\n</code></pre> <p></p> <p>When we deal with very large patterns this structure is much more efficient than using <code>Batch</code> objects with multiple shapes in them. The <code>Batch</code> objects are more flexible and can be used to create more complex patterns. However, they are not as efficient as <code>Pattern</code> objects when it comes to rendering large patterns with the same repeating shape.</p> Patterns are still experimental. <p>With the XeLaTeX backend, the main issue is the memory size that can be set, not the number of shapes. For very large patterns, 50-60 thousand shapes seem to be the limit.</p> <p>In the near future, at least for some cases, we will be able to draw patterns as images. Then patterns could be much more efficent than <code>Batch</code> objects. For now, we can use patterns with the XeLaTeX backend but we need to be careful about the number of shapes in them.</p>"},{"location":"topics/patterns/#hierarchy-of-pattern-objects","title":"Hierarchy of <code>Pattern</code> objects","text":""},{"location":"topics/shapes/","title":"Shapes","text":""},{"location":"topics/shapes/#shape-objects","title":"Shape Objects","text":"<p><code>Shape</code> objects are the fundamental data structure in S\u0130METR\u0130. They are used to represent geometric shapes as connected line segments (polygonal chains). Each <code>Shape</code> object contains a set of vertices that define the shape's geometry, as well as a set of properties that define its appearance, such as fill-color, alpha, and line-width.</p> <p></p> <p>The Structure of <code>Shape</code> objects.</p> <p>We can create a <code>Shape</code> object by using:</p> <p><code>sg.Shape(points: Sequence[Point] = None, closed: bool = False,xform_matrix: array = None, **kwargs)</code></p> <p>If the first and last points are the same, the shape will be <code>closed</code> and the last point will be discarded. If the first and last points are different, the shape will be 'open' unless we set the <code>closed</code> property in the arguments to <code>True</code>. This property can be modified after the object is created. If any other point pair other than the first and last points are the same, the Shape object will raise an error or issue a warning depending on the <code>defaults[\"allow_consec_dup_points\"]</code> setting. The default value for this setting is <code>False</code>. If we want to allow consecutive duplicate points, we can set it to <code>True</code> using <code>sg.defaults[\"allow_consec_dup_points\"] = True</code>. This will allow us to create shapes with consecutive duplicate points without raising an error. This may create problems in some cases, so it is not recommended to use this setting unless we are sure that we need it.</p> <p>Consecutive duplicate points are not allowed in <code>Shape</code> objects, unless we change the default settings!</p>"},{"location":"topics/shapes/#modifying-shape-objects","title":"Modifying Shape Objects","text":"<p>Geometry of Shape objects can be modified by:</p> <ul> <li>Modifying its <code>primary_points</code></li> <li>Modifying its <code>xform_matrix</code></li> <li>Using Python list operations, indexing, or slicing.</li> <li>Transformations with zero repetitions.</li> </ul>"},{"location":"topics/shapes/#using-python-list-operations-indexing-or-slicing","title":"Using Python List Operations, Indexing, or Slicing","text":"<p>Modifying Shape Objects</p> <p>Since Shape objects hold a sequence of 2D points the canonical data structure for this in Python is lists. So, Shape objects' points can be modified by using Python list operations (with some differences) and indexing.</p> <p>Convention for sequences</p> <p>We will use angle brackets for a sequence of objects. <code>&lt;points&gt;</code> means a list, tuple or Numpy array of points.</p>"},{"location":"topics/shapes/#list-operations","title":"List operations","text":"append(point) Add a point to the end of the points. If the Shape object is closed then when drawn this new appended point will be connected to the first point. clear() Remove all points from the Shape. copy() Return a copy of the Shape object. Not just the points but the whole Shape object will be copied. To copy just the vertices use <code>vertices_copy = shape.vertices</code>. count(point, proxy=False) By default it will use exact coordinates for comparison (by using RTOL and ATOL, see the [Numerical Issues] section). If the <code>proxy</code> argument is set to be True than it will search by using distances. extend( or Shape) Add points from another sequence of points or Shape object to the end of the points. It will fail if this would cause redundant points in the Shape object. index(point, start=0, end=None, proxy=False) Return the index of the first occurrence of a specified point. By default it will use exact coordinates for comparison (by using RTOL and ATOL, see the [Numerical Issues] section). If the <code>proxy</code> argument is set to be True than it will search by using distances. It will raise a <code>ValueError</code> if the point is not found. The <code>start</code> and <code>end</code> arguments are optional and can be used to specify a range in which to search for the point. insert(index, point) Insert a point at a specified position. It will fail if this would cause redundant points in the Shape object. pop(ind=-1) Remove and return the point at the specified position (or the last point if no index is specified). remove(point, proxy=False) Remove the first occurrence of a specified point. By default it will use exact coordinates for comparison (by using RTOL and ATOL, see the [Numerical Issues] section). If the <code>proxy</code> argument is set to be True than it will search by using distances. reverse() Reverse the order of the points. sort(key, reverse=False) Sort the points in ascending order (by default) or in descending order by setting the <code>reverse</code> argument to be True. <code>key</code> is a function that takes an (x, y) tuple as an argument and returns a value that will be used for sorting. Unlike Python's sort method the key argument is not optional."},{"location":"topics/shapes/#transforming-shape-objects","title":"Transforming Shape Objects","text":"<p>Shape objects can be translated, mirrored, rotated, scaled, and sheared. They have a method corresponding to each of these transformations. These methods modify the xform_matrix property of the Shape object. The xform_matrix is a 3x3 matrix (more precisely a numpy ndarray) that is used to transform the shape. The xform_matrix can be accessed and modified directly too.</p> <p>None of these transformation methods change the primary_points of the Shape object. The primary_points are the points that define the shape in its original state. Since the vertices are computed by multiplying the primary_points with the xform_matrix, all transformations modify the vertices.</p> <p>Transformations can be combined to apply multiple transformations to a shape. The order of the transformations matters. For example, if we rotate a shape and then translate it, the shape will be rotated around the origin and then translated. If we translate the shape first and then rotate it, the shape will be rotated around the translated origin.</p>"},{"location":"topics/shapes/#composite-transformations","title":"Composite Transformations","text":"<p>Combined (or chained) transformations are called composite transformations. They modify the Shape objects by applying multiple operations in a given order. The order of transformations may be significant depending on the type of transformations used. For example two consecutvie translations may be performed in any order but a translation followed by a rotation may give different results from a rotation followed by a translation.</p> <p>There are three different ways we can perform composite transformations on Shape objects.</p> <ol> <li>Apply individual transformations separately.</li> <li>Apply individual transformations by using method chaining.</li> <li>Matrix multiply the transformations to get a single transformation matrix and use this as an argument in the <code>transform</code> method'.</li> </ol> Inconsistent mathematical convention! <p>Although there is no universally agreed upon convention on how composite transformations should be interpreted, almost all mathematicians (especially in the US) read the composite transformations from right to left. Our convention is the opposite (this is consistent with our Python code that uses row-major matrices). This is less surprising for non-mathematicians. Many old books and some foreign books use the left to right convention as well. As long as we are aware of the distinction this should be OK. The other reason for using our convention is about convenience. If we were to use column-major matrices we would have to be transposing coordinates back and forth and reading coordinates in column-major matrices does not feel natural.</p>"},{"location":"topics/shapes/#transformations-with-repetitions","title":"Transformations with Repetitions","text":"<p>In the previous examples we saw that applied transformations modified the shapes. When we transform a shape with multiple repetitions, the results will be very different. For each repetition a new Shape object will be created and the original Shape object will not be modified. Then the result will be a Batch object with the original Shape object and the new transformed Shape objects. The Batch object can be drawn with the canvas.draw method as well.</p>"},{"location":"topics/shapes/#behind-the-scenes","title":"Behind the Scenes","text":"<p>As we have seen above, transformations can be performed with or without repetitions. When we transform a Shape object without repetition we modify its <code>xform_matrix</code> according to the applied transformation. Shape object's <code>primary_points</code> property stays the same. Since the <code>vertices</code> property is computed by matrix multiplying <code>primary_points</code> and <code>xform_matrix</code>, vertices change accordingly as well.</p> <p>When we apply a transformation with repetitions to a Shape object, this creates an empty Batch object and insert the original shape object (without any modifications) as well as the transformed copies of it. For example, applying a 30 degree rotation about the origin with two repetitions would create a new Batch with the original shape, a 30 degree rotated copy, and a 60 degree rotated copy of the original shape. Two repetitions mean three objects (original Shape object and two transformed copies) in a new Batch object.</p> <p>Transformations with repetitions do not alter the original shape.</p>"},{"location":"topics/shapes/#markers","title":"Markers","text":"<p>Each point in a shape can be drawn with a marker. These markers can be indices of the vertices, coordinates of the vertices, a user provided sequence of string values, a sequence of Shape objects, a sequence of <code>Label</code> objects, an iterator that returns string values, or a function that has an <code>index</code> argument and returns a string value. Markers are explained in the [Cosmetic Features] section. If the <code>markers_only</code> property is True then edges are not drawn.</p>"},{"location":"topics/shapes/#cosmetic-features","title":"Cosmetic Features","text":"<p>Shape objects are drawn by the <code>Canvas</code> objects using their cosmetic properties as shown below.</p> <ul> <li>Line thickness: <code>shape.line_width</code></li> <li>Line color: <code>shape.line_color</code></li> <li>Line color transparency: <code>shape.line_alpha</code></li> <li>Line join type: <code>shape.line_join</code></li> <li>Line cap style: <code>shape.line_cap</code></li> <li>Line miter limit: <code>shape.line_miter_limit</code></li> <li>Line pattern: <code>shape.line_dash_array</code></li> <li>Line pattern phase: <code>shape.line_dash_phase</code></li> <li>Fill color: <code>shape.fill_color</code></li> <li>Fill color transparency: <code>shape.fill_alpha</code></li> <li>Fill pattern: <code>shape.fill_pattern</code></li> <li>Shading: <code>shape.shading</code></li> <li>Even odd rule: <code>shape.fill_mode</code></li> <li>Filled: <code>shape.fill</code></li> <li>Lined: <code>shape.stroke</code></li> <li>Draw with markers: <code>shape.draw_markers</code></li> <li>Marker: <code>shape.marker</code></li> <li>Draw fillets: <code>shape.draw_fillets</code></li> <li>Fillet radius: <code>shape.fillet_radius</code></li> <li>Curved edges: <code>shape.smooth</code></li> </ul>"},{"location":"topics/styling/","title":"Line-style","text":""},{"location":"topics/styling/#style-attributes","title":"Style Attributes","text":""},{"location":"topics/styling/#aliases","title":"Aliases","text":"<p>The style attributes of a shape or batch object are defined through their <code>style</code> property. Depending on the type of object, the style attributes may vary. Similar to the <code>bounding-box</code> property, we can use aliases to access the style attributes of a shape or batch object. T</p>"},{"location":"topics/styling/#line-style-attributes","title":"Line-Style Attributes","text":"<code>item.stroke -&gt; item.style.line_style.stroke</code>: <p>Visibility of the contour lines. It can be a boolean value indicating whether to draw the contour lines or not.</p> <p>The default value is <code>True</code>.</p> <code>item.line_width -&gt; item.style.line_style.width</code>: <p>Line-width of the contour lines. Positive float value or LineWidth value.</p> <ul> <li>LineWidth.ULTRA_THIN</li> <li>LineWidth.VERY_THIN</li> <li>LineWidth.THIN</li> <li>LineWidth.THICK</li> <li>LineWidth.VERY_THICK</li> <li>LineWidth.ULTRA_THICK</li> </ul> <p>The default value is 1.</p> <code>item.line_color -&gt; item.style.line_style.color</code>: <p>Line-color of the contour lines. It can be a color name, hex code, or RGB tuple. See the colors for more information.</p> <p>The default value is <code>sg.black</code>.</p> <code>item.line_dash_array -&gt; item.style.line_style.dash_array</code>: <p>Line-dash array of the shape object. It can be a list of floats or a string representing the dash pattern. For example, <code>item.line_dash_array = [5, 2]</code> will create a dashed line with 5 units of dash and 2 units of space.</p> <ul> <li>LineDashArray.DASHDOT</li> <li>LineDashArray.DASHED</li> <li>LineDashArray.DASHDOTDOT</li> <li>LineDashArray.DENSELY_DASHED</li> <li>LineDashArray.DENSELY_DOTTED</li> <li>LineDashArray.LOOSELY_DASHED</li> </ul> <p>The default value is <code>None</code>.</p> <code>item.line_dash_phase -&gt; item.style.line_style.dash_phase</code>: Line-dash phase of the contour lines. It can be a float value representing the phase offset of the dash pattern. <code>item.line_cap -&gt; item.style.line_style.cap</code>: <p>Line-cap of the contour lines.</p> <ul> <li>LineCap.BUTT</li> <li>LineCap.ROUND</li> <li>LineCap.SQUARE</li> </ul> <p>The default value is <code>LineCap.BUTT</code>.</p> <code>item.line_join -&gt; item.style.line_style.join</code>: <p>Line-join of the contour lines.</p> <ul> <li>LineJoin.BEVEL</li> <li>LineJoin.MITER</li> <li>LineJoin.ROUND</li> </ul> <p>The default value is <code>LineJoin.MITER</code>.</p> <code>item.fillet_radius -&gt; item.style.line_style.fillet_radius</code>: <p>Fillet radius of the contour lines. It can be a float value representing the radius of the fillet.</p> <p>The default value is 0.</p> <code>item.draw_fillets -&gt; item.style.line_style.draw_fillets</code>: <p>Draw fillets of the contour lines. It can be a boolean value indicating whether to draw fillets or not.</p> <p>The default value is <code>False</code>.</p> <code>item.smooth -&gt; item.style.line_style.smooth</code>: <p>Smoothness of the contour lines. It can be a boolean value indicating whether to smooth the contour lines or not.</p> <p>The default value is <code>False</code>.</p> <code>item.double_lines -&gt; item.style.line_style.double_lines</code>: <p>Draw double lines of the contour lines. It can be a boolean value indicating whether to draw double lines or not.</p> <p>The default value is <code>False</code>.</p> <code>item.double_distance -&gt; item.style.line_style.double_distance</code>: <p>Distance between the double lines of the contour lines. It can be a float value representing the distance between the double lines.</p> <p>The default value is 0.</p>"},{"location":"topics/tilings/","title":"Tilings","text":""},{"location":"topics/tilings/#tilings","title":"Tilings","text":"<p>It is possible to create tilings by using shapes and transformations. There will be a specific tilings module in the future. It is a very broad topic and it is tough to cover all the possibilities.</p> <p>If you are interested in creating tilings, you can check out the Tilings &amp; Patterns by Branko Gr\u00fcnbaum &amp; G.C. Shepard. It is a great resource for learning about different types of tilings and how to create them.</p>"},{"location":"topics/transformations/","title":"Transformations","text":""},{"location":"topics/transformations/#transformations","title":"Transformations","text":"<p>Transformations are used to change the position, size, and orientation of shapes, paths, images, and batches. In S\u0130METR\u0130, transformations are performed using transformation matrices. The transformation matrix is a mathematical representation of the transformation that can be applied to the points of the object.</p> <p>Transformations can be performed successively by using repetitions. The number of repetitions can be specified using the <code>reps</code> argument. The default value is 0. This is a very powerful technique to create intricate patterns with ease.</p> <p>When an object is not active, it cannot be transformed.</p>"},{"location":"topics/transformations/#transformation-types","title":"Transformation Types","text":"<p>All <code>Shape</code>, <code>LinPath</code>, <code>Image</code>, and <code>Batch</code> objects can be transformed by using one of the following methods:</p> <ul> <li><code>translate(dx: float, dy: float, reps: int=0, key: Callable=None)</code></li> <li><code>rotate(angle: float, about: Point, reps: int=0, key: Callable=None)</code></li> <li><code>mirror(about: Line, reps: int=0, key: Callable=None)</code></li> <li><code>scale(scale_x: float, scale_y: float, about: Point, reps: int=0, key: Callable=None)</code></li> <li><code>glide(mirror_line: Line, distance: float, reps: int=0, key: Callable=None)</code></li> <li><code>shear(angle_x: float, angle_y: float, reps: int=0, key: Callable=None)</code></li> <li><code>transform(transform_matrix: array, reps: int=0, key: Callable=None)</code></li> </ul> <p>There is a special transformation method called <code>move_to</code> that can be used to move a shape, path, image, or batch object to a new position without changing its size or orientation. The <code>move_to</code> method moves the midpoint of the target object's boundary box to the specified position by default. This can be changed by specifying an anchor point. The <code>move_to</code> method has the following signature:</p> <p><code>move_to(pos: Point, anchor: Anchor=sg.Anchor.CENTER)</code></p>"},{"location":"topics/transformations/#example","title":"Example:","text":"<ul> <li><code>shape.glide(mirror_line=[(0, 0), (1, 1)], distance=45.5)</code></li> <li><code>shape.scale(scale_x=1, scale_y=2.5)</code></li> <li><code>shape.rotate(angle=sg.pi/4)</code></li> </ul>"},{"location":"topics/transformations/#composite-transformations","title":"Composite Transformations","text":"<p>Composite transformations can be created by matrix-multiplying transformation matrices and then using the <code>transform</code> method. S\u0130METR\u0130 provides the following transformation matrices:</p> <ul> <li><code>identity_matrix() -&gt; array</code></li> <li><code>translation_matrix(dx: float, dy: float) -&gt; array</code></li> <li><code>rot_about_origin_matrix(angle: float) -&gt; array</code></li> <li><code>rotation_matrix(angle: float, about: Point) -&gt; array</code></li> <li><code>mirror_matrix(about: Line) -&gt; array</code></li> <li><code>scale_matrix(scale_x: float, scale_y: float, about: Point) -&gt; array</code></li> <li><code>scale_in_place_matrix(scale_x: float, scale_y: float, about: Point) -&gt; array</code></li> <li><code>glide_matrix(mirror_line: Line, distance: float) -&gt; array</code></li> <li><code>glide_in_place_matrix(mirror_line: Line, distance: float) -&gt; array</code></li> <li><code>shear_matrix(angle_x: float, angle_y: float) -&gt; array</code></li> </ul> <p>And their inverse matrices:</p> <ul> <li><code>inv_translation_matrix(dx: float, dy: float) -&gt; array</code></li> <li><code>inv_rotation_matrix(angle: float, about: Point) -&gt; array</code></li> <li><code>inv_scale_matrix(scale_x: float, scale_y: float, about: Point) -&gt; array</code></li> <li><code>inv_glide_matrix(mirror_line: Line, distance: float) -&gt; array</code></li> <li><code>inv_shear_matrix(angle_x: float, angle_y: float) -&gt; array</code></li> </ul> There are no inverse matrices for <code>identity_matrix</code> and <code>mirror_matrix</code>! <p>Inverses of <code>identity_matrix</code> and <code>mirror_matrix</code> are themselves.</p>"},{"location":"topics/transformations/#example_1","title":"Example:","text":"Composite Transformations<pre><code>    import simetri.graphics as sg\n\n    shape = sg.Shape(points=[(0, 0), (10, 10), (50, -30)])\n\n    translation = sg.translation_matrix(10, 20)\n    rotation = sg.rotation_matrix(sg.pi/4)\n    scale = sg.scale_matrix(2)\n\n    transform = translation @ rotation @ scale\n    shape.transform(transform_matrix=transform, reps=2)\n</code></pre>"},{"location":"topics/transformations/#transformations-without-repetitions","title":"Transformations Without Repetitions","text":"<p>Transformations without repetitions are used to modify an object's position, size, or orientation without creating multiple copies of the object. This is useful when you want to apply a transformation to an object without creating a pattern or repeating the transformation.</p> <p>Since the default value of the <code>reps</code> argument is <code>0</code>, the transformation will be applied to the object without creating any copies.</p>"},{"location":"topics/transformations/#transforming-batch-objects-without-repetitions","title":"Transforming <code>Batch</code> Objects Without Repetitions","text":"<p>When we apply a transformation to a <code>Batch</code> object, the transformation will be applied to all the applicable items in the batch. The number of items in the batch will remain unchanged.</p>"},{"location":"topics/transformations/#transformations-with-repetitions","title":"Transformations With Repetitions","text":"<p>Transformations with repetitions are used to create multiple copies of an object with the same transformation applied to each copy successively. This is useful when you want to design a pattern of the target object.</p> <p>The following snippet shows the equivalent way to create a pattern by using a Python loop.</p> <p>Transformations with repetitions<pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\ns = 25 # scale factor\ncanvas.help_lines(pos=(-2*s, -2*s), width=18*s, height=16*s, spacing=s)\n\ntriangle = sg.Shape(points=[(0, 3*s), (3*s, 6*s), (5*s, s)], closed=True)\n\ndef translate_shape(shape, dx, dy, reps):\n    batch = sg.Batch(shape)\n    for _ in range(reps):\n        shape = shape.copy()\n        shape.translate(dx=dx, dy=dy)\n        batch.append(shape)\n\n    return batch\n\nbatch1 = translate_shape(triangle, dx=2*s, dy=0, reps=5)\n\ntriangle2 = triangle.copy()\nbatch2 = triangle2.translate(dx=2*s, dy=0, reps=5)\n\ncanvas.draw(batch1, fill_color=sg.amber)\ncanvas.translate(dx=0, dy=7*s)\ncanvas.draw(batch2, fill_color=sg.teal).display()\n</code></pre> </p>"},{"location":"topics/transformations/#a-common-mistake","title":"A Common Mistake","text":"<p>When we transform a <code>Shape</code> object with multiple repetitions, the result of this operation is a new <code>Batch</code> object with the original shape as well as the transformed copies of the original. This operation does not modify the original shape object. </p> <p>Multiple repetitions do not modify the original object.</p> <p>If we apply a transformation with multiple repetitions to a <code>Batch</code> object, the transformed copies of the items in the batch will be added to the batch. The original items in the batch will remain unchanged.</p> <p>Transforming <code>Batch</code> objects with multiple repetitions grow them.</p> <code>Shape</code> objects<code>Batch</code> objects Transforming a `Shape` with repetitions<pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ns = 25 # scale factor\ncanvas.help_lines(pos=(-2*s, -2*s), width=12*s, height=10*s, spacing=s)\n\ntriangle = sg.Shape(points=[(0, 3*s), (3*s, 6*s), (5*s, s)], closed=True)\ntriangle.translate(dx=2*s, dy=0, reps=5) # (1)!\n\ncanvas.draw(triangle, fill_color=sg.amber).display()\n</code></pre> <ol> <li> <p>A common mistake</p>  Since the number of repetitions is not zero, the <code>translate</code> method does not modify the original shape object. It creates a new batch object with the original shape and the transformed copies of the original. The original shape object remains unchanged. To capture the returned <code>Batch</code> object that contains the original and the transformed copies, use:  <code>triangles = triangle.translate(dx=2*s, dy=0, reps=5)</code> <code>canvas.draw(triangles)</code> Alternatively, if you don't need to reuse the returned <code>Batch</code> object, you can use: <code>canvas.draw(triangle.translate(dx=2*s, dy=0, reps=5))</code> </li> </ol> <p></p> Transforming a `Batch` object with repetitions<pre><code>import simetri.graphics as sg\n\ncanvas = sg.Canvas()\n\ns = 25 # scale factor\ncanvas.help_lines(pos=(-2*s, -2*s), width=12*s, height=10*s, spacing=s)\n\nshape = sg.Shape(points=[(0, 3*s), (3*s, 6*s), (5*s, s)], closed=True)\ntriangle = sg.Batch(shape)\ntriangle.translate(dx=2*s, dy=0, reps=5) # (1)!\n\ncanvas.draw(triangle, fill_color=sg.amber).display()\n</code></pre> <ol> <li> <p>Now the transformation is applied to a <code>Batch</code> object.</p> </li> </ol> <p></p> We should be aware of the transformed object's type. <p>The result may be different depending on the type of the object we are transforming.</p> <p>For transformations of <code>Image</code> objects, see the image-transformations section.</p>"},{"location":"topics/style/line_style/","title":"Fill-style","text":""},{"location":"topics/style/line_style/#style-attributes","title":"Style Attributes","text":""},{"location":"topics/style/line_style/#aliases","title":"Aliases","text":"<p>The style attributes of a shape or batch object are defined through their <code>style</code> property. Depending on the type of object, the style attributes may vary. Similar to the <code>bounding-box</code> property, we can use aliases to access the style attributes of a shape or batch object. T</p>"},{"location":"topics/style/line_style/#line-style-attributes","title":"Line-Style Attributes","text":"<code>item.stroke -&gt; item.style.line_style.stroke</code>: <p>Visibility of the contour lines. It can be a boolean value indicating whether to draw the contour lines or not.</p> <p>The default value is <code>True</code>.</p> <code>item.line_width -&gt; item.style.line_style.width</code>: <p>Line-width of the contour lines. Positive float value or LineWidth value.</p> <ul> <li>LineWidth.ULTRA_THIN</li> <li>LineWidth.VERY_THIN</li> <li>LineWidth.THIN</li> <li>LineWidth.THICK</li> <li>LineWidth.VERY_THICK</li> <li>LineWidth.ULTRA_THICK</li> </ul> <p>The default value is 1.</p> <code>item.line_color -&gt; item.style.line_style.color</code>: <p>Line-color of the contour lines. It can be a color name, hex code, or RGB tuple. See the colors for more information.</p> <p>The default value is <code>sg.black</code>.</p> <code>item.line_dash_array -&gt; item.style.line_style.dash_array</code>: <p>Line-dash array of the shape object. It can be a list of floats or a string representing the dash pattern. For example, <code>item.line_dash_array = [5, 2]</code> will create a dashed line with 5 units of dash and 2 units of space.</p> <ul> <li>LineDashArray.DASHDOT</li> <li>LineDashArray.DASHED</li> <li>LineDashArray.DASHDOTDOT</li> <li>LineDashArray.DENSELY_DASHED</li> <li>LineDashArray.DENSELY_DOTTED</li> <li>LineDashArray.LOOSELY_DASHED</li> </ul> <p>The default value is <code>None</code>.</p> <code>item.line_dash_phase -&gt; item.style.line_style.dash_phase</code>: Line-dash phase of the contour lines. It can be a float value representing the phase offset of the dash pattern. <code>item.line_cap -&gt; item.style.line_style.cap</code>: <p>Line-cap of the contour lines.</p> <ul> <li>LineCap.BUTT</li> <li>LineCap.ROUND</li> <li>LineCap.SQUARE</li> </ul> <p>The default value is <code>LineCap.BUTT</code>.</p> <code>item.line_join -&gt; item.style.line_style.join</code>: <p>Line-join of the contour lines.</p> <ul> <li>LineJoin.BEVEL</li> <li>LineJoin.MITER</li> <li>LineJoin.ROUND</li> </ul> <p>The default value is <code>LineJoin.MITER</code>.</p> <code>item.fillet_radius -&gt; item.style.line_style.fillet_radius</code>: <p>Fillet radius of the contour lines. It can be a float value representing the radius of the fillet.</p> <p>The default value is 0.</p> <code>item.draw_fillets -&gt; item.style.line_style.draw_fillets</code>: <p>Draw fillets of the contour lines. It can be a boolean value indicating whether to draw fillets or not.</p> <p>The default value is <code>False</code>.</p> <code>item.smooth -&gt; item.style.line_style.smooth</code>: <p>Smoothness of the contour lines. It can be a boolean value indicating whether to smooth the contour lines or not.</p> <p>The default value is <code>False</code>.</p> <code>item.double_lines -&gt; item.style.line_style.double_lines</code>: <p>Draw double lines of the contour lines. It can be a boolean value indicating whether to draw double lines or not.</p> <p>The default value is <code>False</code>.</p> <code>item.double_distance -&gt; item.style.line_style.double_distance</code>: <p>Distance between the double lines of the contour lines. It can be a float value representing the distance between the double lines.</p> <p>The default value is 0.</p>"},{"location":"Categories/books/","title":"Category: Books","text":""},{"location":"Categories/books/#pages-in-category-books","title":"Pages in category \"Books\"","text":"<ul> <li>Anadolu Sel\u00e7uklu Sanat\u0131n\u0131n Geometrik Dili by Serap Ekizler S\u00f6nmez</li> <li>Designing tessellations: The Secrets of Interlocking Patterns by Jinny Beyer</li> <li>Handbook of regular patterns: An introduction to symmetry in two dimensions by Peter S. Stevens (Author)</li> <li>How to Draw the Mozaics of the Alhambra by Manuel Mart\u00ednez Vela</li> <li>Introduction to Graph Theory by  Richard J. Trudeau</li> <li>Islamic Geometric Patterns</li> <li>Islamic Ornamental Design by Claude Humbert</li> <li>M.C. Escher : Visions of Symmetry by Doris Schattschneider</li> <li>Mathematical Illustrations by Robert Casselman</li> <li>Space Tessellations: Experimenting with Parquet Deformations by Werner van Hoeydonck (Editor), Christian Kern (Editor), Eva Sommeregger (Editor)</li> <li>The Fascination of Groups by F.J. Budden</li> <li>The Symmetries of Things by John H. Conway, Heidi Burgiel, and Chaim Goodman-Strauss</li> <li>The Topkapi Scroll: Geometry and Ornament in Islamic Architecture by G\u00fclru Necipo\u011flu</li> <li>Tilings and Patterns: Second Edition (Dover Books on Mathematics) 2<sup>nd</sup> Edition by Branko Gr\u00fcnbaum &amp; G.C. Shepard</li> <li>Traditional Islamic Craft in Moroccan Architecture (Vol.1 &amp; 2) by Andre Paccard</li> </ul> <p>All Categories</p>"},{"location":"Categories/tutorials/","title":"Category: Tutorials","text":""},{"location":"Categories/tutorials/#pages-in-category-tutorials","title":"Pages in category \"Tutorials\"","text":"<p>All Categories</p>"},{"location":"Categories/elements/","title":"Category: Elements","text":""},{"location":"Categories/elements/#pages-in-category-elements","title":"Pages in category \"Elements\"","text":"<p>All Categories</p>"},{"location":"Categories/","title":"All Categories","text":"<p>There are a total of 3 categories(s):</p> <ul> <li>Books (15)</li> <li>Elements (1)</li> <li>Tutorials (1)</li> </ul>"},{"location":"archive/2025/","title":"2025","text":""},{"location":"category/tutorials/","title":"Tutorials","text":""}]}